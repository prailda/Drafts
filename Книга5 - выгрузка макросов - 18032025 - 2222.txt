
'-------------------------------------------
' Component: ICommand
'-------------------------------------------
' -----------------------------------------------------
' Класс: ICommand
' Описание: Определяет интерфейс для всех команд системы
' -----------------------------------------------------
Option Explicit

' Выполнение команды
Public Function Execute() As Boolean
    ' Пустая реализация для интерфейса
End Function

' Отмена команды
Public Function Undo() As Boolean
    ' Пустая реализация для интерфейса
End Function

' Получение имени команды
Public Function GetCommandName() As String
    ' Пустая реализация для интерфейса
End Function

' Получение уникального идентификатора команды
Public Function GetIdentifier() As String
    ' Пустая реализация для интерфейса
End Function

' Признак успешного выполнения команды
Public Function WasExecutedSuccessfully() As Boolean
    ' Пустая реализация для интерфейса
End Function

' Признак успешной отмены команды
Public Function WasUndoneSuccessfully() As Boolean
    ' Пустая реализация для интерфейса
End Function

' Получение временной метки выполнения
Public Function GetExecutionTimestamp() As Date
    ' Пустая реализация для интерфейса
End Function

' Получение временной метки отмены
Public Function GetUndoTimestamp() As Date
    ' Пустая реализация для интерфейса
End Function

'-------------------------------------------
' Component: BaseCommand
'-------------------------------------------
' -----------------------------------------------------
' Класс: BaseCommand
' Описание: Базовая реализация команды с общей функциональностью
' -----------------------------------------------------
Option Explicit

Implements ICommand

' Внутренняя структура для данных команды
Private Type TBaseCommand
    CommandName As String          ' Имя команды
    Identifier As String           ' Уникальный идентификатор
    ExecutionTimestamp As Date     ' Время выполнения
    UndoTimestamp As Date          ' Время отмены
    ExecutedSuccessfully As Boolean ' Успешно ли выполнена
    UndoneSuccessfully As Boolean  ' Успешно ли отменена
    Logger As Object               ' Объект логгера
    errorHandler As Object         ' Объект для обработки ошибок
    IsInitialized As Boolean       ' Флаг инициализации
End Type

Private this As TBaseCommand

' Инициализация
Private Sub Class_Initialize()
    this.CommandName = TypeName(Me)
    this.Identifier = GenerateUniqueID()
    this.ExecutedSuccessfully = False
    this.UndoneSuccessfully = False
    this.IsInitialized = False
    
    ' Получаем глобальные сервисы
    Set this.Logger = GetLogger()  ' Функция должна быть реализована в модуле
    Set this.errorHandler = GetErrorHandler()  ' Функция должна быть реализована в модуле
End Sub

' Генерация уникального идентификатора
Private Function GenerateUniqueID() As String
    ' Создаем ID в формате: ИмяКоманды_Дата_Время_СлучайноеЧисло
    Dim currentTime As Date
    currentTime = Now
    Randomize  ' Инициализация генератора случайных чисел
    GenerateUniqueID = this.CommandName & "_" & _
                     Format(currentTime, "yyyymmdd_hhnnss") & "_" & _
                     Format(Int(Rnd() * 10000), "0000")
End Function

' Инициализация базовых параметров команды
Public Sub InitializeBase(Optional CommandName As String = "")
    If Len(CommandName) > 0 Then
        this.CommandName = CommandName
        this.Identifier = GenerateUniqueID()  ' Пересоздаем ID с новым именем
    End If
    this.IsInitialized = True
End Sub

' Реализация интерфейса ICommand
Private Function ICommand_Execute() As Boolean
    On Error GoTo errorHandler
    
    ' Проверка инициализации
    If Not this.IsInitialized Then
        this.Logger.LogWarning "Попытка выполнения неинициализированной команды", this.CommandName
        ICommand_Execute = False
        Exit Function
    End If
    
    ' Фиксация времени выполнения
    this.ExecutionTimestamp = Now
    this.Logger.LogInfo "Начало выполнения команды", this.CommandName
    
    ' Вызов абстрактного метода
    ICommand_Execute = OnExecute()
    
    ' Обработка результата
    If ICommand_Execute Then
        this.ExecutedSuccessfully = True
        this.Logger.LogInfo "Команда выполнена успешно", this.CommandName
    Else
        this.ExecutedSuccessfully = False
        this.Logger.LogWarning "Команда не выполнена", this.CommandName
    End If
    
    Exit Function
    
errorHandler:
    this.ExecutedSuccessfully = False
    this.Logger.LogError "Ошибка выполнения команды: " & err.Description, this.CommandName
    
    If Not this.errorHandler Is Nothing Then
        this.errorHandler.HandleError err, "Execute", Me
    End If
    
    ICommand_Execute = False
End Function

Private Function ICommand_Undo() As Boolean
    On Error GoTo errorHandler
    
    ' Проверка инициализации
    If Not this.IsInitialized Then
        this.Logger.LogWarning "Попытка отмены неинициализированной команды", this.CommandName
        ICommand_Undo = False
        Exit Function
    End If
    
    ' Проверка, была ли команда выполнена
    If Not this.ExecutedSuccessfully Then
        this.Logger.LogWarning "Попытка отмены невыполненной команды", this.CommandName
        ICommand_Undo = False
        Exit Function
    End If
    
    ' Фиксация времени отмены
    this.UndoTimestamp = Now
    this.Logger.LogInfo "Начало отмены команды", this.CommandName
    
    ' Вызов абстрактного метода
    ICommand_Undo = OnUndo()
    
    ' Обработка результата
    If ICommand_Undo Then
        this.UndoneSuccessfully = True
        this.Logger.LogInfo "Команда отменена успешно", this.CommandName
    Else
        this.UndoneSuccessfully = False
        this.Logger.LogWarning "Команда не отменена", this.CommandName
    End If
    
    Exit Function
    
errorHandler:
    this.UndoneSuccessfully = False
    this.Logger.LogError "Ошибка отмены команды: " & err.Description, this.CommandName
    
    If Not this.errorHandler Is Nothing Then
        this.errorHandler.HandleError err, "Undo", Me
    End If
    
    ICommand_Undo = False
End Function

' Реализация остальных методов интерфейса
Private Function ICommand_GetCommandName() As String
    ICommand_GetCommandName = this.CommandName
End Function

Private Function ICommand_GetIdentifier() As String
    ICommand_GetIdentifier = this.Identifier
End Function

Private Function ICommand_WasExecutedSuccessfully() As Boolean
    ICommand_WasExecutedSuccessfully = this.ExecutedSuccessfully
End Function

Private Function ICommand_WasUndoneSuccessfully() As Boolean
    ICommand_WasUndoneSuccessfully = this.UndoneSuccessfully
End Function

Private Function ICommand_GetExecutionTimestamp() As Date
    ICommand_GetExecutionTimestamp = this.ExecutionTimestamp
End Function

Private Function ICommand_GetUndoTimestamp() As Date
    ICommand_GetUndoTimestamp = this.UndoTimestamp
End Function

' "Абстрактные" методы для переопределения в наследниках
Public Function OnExecute() As Boolean
    ' Базовая реализация для "абстрактного" метода
    err.Raise 5, "BaseCommand", "Метод OnExecute должен быть переопределен в наследнике"
    OnExecute = False
End Function

Public Function OnUndo() As Boolean
    ' Базовая реализация для "абстрактного" метода
    err.Raise 5, "BaseCommand", "Метод OnUndo должен быть переопределен в наследнике"
    OnUndo = False
End Function

' Getter-методы для доступа к защищенным свойствам
Public Property Get CommandName() As String
    CommandName = this.CommandName
End Property

Public Property Get Logger() As Object
    Set Logger = this.Logger
End Property

Public Property Get errorHandler() As Object
    Set errorHandler = this.errorHandler
End Property


'-------------------------------------------
' Component: ValidatableCommand
'-------------------------------------------
' -----------------------------------------------------
' Класс: ValidatableCommand
' Описание: Расширение базовой команды с функциональностью валидации
' -----------------------------------------------------
Option Explicit

' Наследуем от BaseCommand
Implements ICommand

' Внутренняя структура для данных
Private Type TValidatableCommand
    BaseCommand As BaseCommand     ' Базовая команда (делегирование)
    ValidationManager As Object    ' Менеджер валидации
    ValidationErrors As String     ' Ошибки валидации
    IsValidated As Boolean         ' Была ли выполнена валидация
    isValid As Boolean             ' Валидна ли команда
End Type

Private this As TValidatableCommand

' Инициализация
Private Sub Class_Initialize()
    Set this.BaseCommand = New BaseCommand
    this.ValidationErrors = ""
    this.IsValidated = False
    this.isValid = False
    
    ' Получаем менеджер валидации
    Set this.ValidationManager = GetValidationManager()  ' Функция должна быть реализована в модуле
End Sub

' Инициализация базовых параметров
Public Sub InitializeBase(Optional CommandName As String = "")
    this.BaseCommand.InitializeBase IIf(Len(CommandName) > 0, CommandName, TypeName(Me))
    
    ' Сбрасываем состояние валидации при изменении параметров
    this.IsValidated = False
    this.ValidationErrors = ""
End Sub

' Валидация команды
Public Function Validate() As Boolean
    ' Очищаем предыдущие результаты валидации
    this.ValidationErrors = ""
    this.IsValidated = True
    this.isValid = True
    
    ' Вызываем метод для переопределения в наследниках
    Validate = DoValidate()
    
    ' Сохраняем результат
    this.isValid = Validate
End Function

' Проверка валидности команды
Public Function isValid() As Boolean
    ' Если валидация еще не выполнялась, выполняем ее
    If Not this.IsValidated Then
        Validate
    End If
    
    isValid = this.isValid
End Function

' Получение сообщений об ошибках валидации
Public Function GetValidationErrors() As String
    ' Если валидация еще не выполнялась, выполняем ее
    If Not this.IsValidated Then
        Validate
    End If
    
    GetValidationErrors = this.ValidationErrors
End Function

' Метод для переопределения в наследниках
Public Function DoValidate() As Boolean
    ' Базовая реализация (всегда проходит валидацию)
    DoValidate = True
End Function

' Добавление ошибки валидации
Protected Sub AddValidationError(errorMessage As String)
    If Len(this.ValidationErrors) > 0 Then
        this.ValidationErrors = this.ValidationErrors & vbCrLf
    End If
    
    this.ValidationErrors = this.ValidationErrors & ErrorMessage
    this.isValid = False
End Sub

' Реализация ICommand через делегирование BaseCommand
' Но с добавлением валидации перед Execute
Private Function ICommand_Execute() As Boolean
    ' Проверяем валидность перед выполнением
    If Not isValid() Then
        this.BaseCommand.Logger.LogWarning "Попытка выполнить невалидную команду: " & this.ValidationErrors, _
                                          this.BaseCommand.CommandName
        ICommand_Execute = False
        Exit Function
    End If
    
    ' Делегируем выполнение базовому классу
    ICommand_Execute = this.BaseCommand.OnExecute()
End Function

' Делегирование остальных методов ICommand базовому классу
Private Function ICommand_Undo() As Boolean
    ICommand_Undo = this.BaseCommand.OnUndo()
End Function

Private Function ICommand_GetCommandName() As String
    ICommand_GetCommandName = this.BaseCommand.CommandName
End Function

Private Function ICommand_GetIdentifier() As String
    ICommand_GetIdentifier = this.BaseCommand.GetIdentifier()
End Function

Private Function ICommand_WasExecutedSuccessfully() As Boolean
    ICommand_WasExecutedSuccessfully = this.BaseCommand.WasExecutedSuccessfully()
End Function

Private Function ICommand_WasUndoneSuccessfully() As Boolean
    ICommand_WasUndoneSuccessfully = this.BaseCommand.WasUndoneSuccessfully()
End Function

Private Function ICommand_GetExecutionTimestamp() As Date
    ICommand_GetExecutionTimestamp = this.BaseCommand.GetExecutionTimestamp()
End Function

Private Function ICommand_GetUndoTimestamp() As Date
    ICommand_GetUndoTimestamp = this.BaseCommand.GetUndoTimestamp()
End Function

' Переопределяем методы базового класса
Public Function OnExecute() As Boolean
    ' Базовая реализация
    err.Raise 5, "ValidatableCommand", "Метод OnExecute должен быть переопределен в наследнике"
    OnExecute = False
End Function

Public Function OnUndo() As Boolean
    ' Базовая реализация
    err.Raise 5, "ValidatableCommand", "Метод OnUndo должен быть переопределен в наследнике"
    OnUndo = False
End Function

' Геттеры для доступа к защищенным свойствам
Public Property Get CommandName() As String
    CommandName = this.BaseCommand.CommandName
End Property

Public Property Get Logger() As Object
    Set Logger = this.BaseCommand.Logger
End Property

Public Property Get ValidationManager() As Object
    Set ValidationManager = this.ValidationManager
End Property


'-------------------------------------------
' Component: CommandMemento
'-------------------------------------------
' -----------------------------------------------------
' Класс: CommandMemento
' Описание: Хранит снимок состояния команды для возможности отмены
' -----------------------------------------------------
Option Explicit

Private Type TCommandMemento
    state As Object        ' Словарь (Dictionary) для хранения состояния
    commandID As String    ' Идентификатор команды
    Timestamp As Date      ' Время создания снимка
End Type

Private this As TCommandMemento

' Инициализация
Private Sub Class_Initialize()
    Set this.state = CreateObject("Scripting.Dictionary")
    this.Timestamp = Now
End Sub

' Установка состояния
Public Sub SetState(stateData As Object, commandID As String)
    Set this.state = stateData
    this.commandID = commandID
    this.Timestamp = Now
End Sub

' Получение состояния
Public Function GetState() As Object
    Set GetState = this.state
End Function

' Получение идентификатора команды
Public Function GetCommandID() As String
    GetCommandID = this.commandID
End Function

' Получение времени создания снимка
Public Function GetTimestamp() As Date
    GetTimestamp = this.Timestamp
End Function

' Проверка, содержит ли снимок данные
Public Function HasState() As Boolean
    HasState = (Not this.state Is Nothing) And (this.state.count > 0)
End Function

'-------------------------------------------
' Component: UndoableCommand
'-------------------------------------------
' -----------------------------------------------------
' Класс: UndoableCommand
' Описание: Расширение базовой команды с поддержкой отмены через Memento
' -----------------------------------------------------
Option Explicit

' Наследуем от BaseCommand
Implements ICommand

' Внутренняя структура для данных
Private Type TUndoableCommand
    BaseCommand As BaseCommand     ' Базовая команда (делегирование)
    memento As CommandMemento      ' Снимок состояния для отмены
    MementoCreated As Boolean      ' Был ли создан снимок
End Type

Private this As TUndoableCommand

' Инициализация
Private Sub Class_Initialize()
    Set this.BaseCommand = New BaseCommand
    Set this.memento = New CommandMemento
    this.MementoCreated = False
End Sub

' Инициализация базовых параметров
Public Sub InitializeBase(Optional CommandName As String = "")
    this.BaseCommand.InitializeBase IIf(Len(CommandName) > 0, CommandName, TypeName(Me))
End Sub

' Создание снимка состояния
Public Function CreateMemento() As CommandMemento
    ' Получаем состояние от наследника
    Dim stateData As Object
    Set stateData = SaveState()
    
    ' Сохраняем в Memento
    this.memento.SetState stateData, this.BaseCommand.GetIdentifier()
    this.MementoCreated = True
    
    Set CreateMemento = this.memento
End Function

' Восстановление из снимка
Public Sub RestoreFromMemento(memento As CommandMemento)
    If memento Is Nothing Then Exit Sub
    
    ' Проверяем, что снимок принадлежит этой команде
    If memento.GetCommandID() <> this.BaseCommand.GetIdentifier() Then
        this.BaseCommand.Logger.LogWarning "Попытка восстановления из снимка другой команды", _
                                          this.BaseCommand.CommandName
        Exit Sub
    End If
    
    ' Восстанавливаем состояние
    RestoreState memento.GetState()
End Sub

' Метод для переопределения в наследниках - сохранение состояния
Public Function SaveState() As Object
    ' Базовая реализация
    Set SaveState = CreateObject("Scripting.Dictionary")
End Function

' Метод для переопределения в наследниках - восстановление состояния
Public Sub RestoreState(stateData As Object)
    ' Базовая реализация (пустая)
End Sub

' Реализация ICommand через делегирование BaseCommand
Private Function ICommand_Execute() As Boolean
    ' Сохраняем состояние перед выполнением
    CreateMemento
    
    ' Делегируем выполнение базовому классу
    ICommand_Execute = this.BaseCommand.OnExecute()
End Function

Private Function ICommand_Undo() As Boolean
    ' Проверяем, что снимок был создан
    If Not this.MementoCreated Then
        this.BaseCommand.Logger.LogWarning "Попытка отмены команды без сохраненного состояния", _
                                          this.BaseCommand.CommandName
        ICommand_Undo = False
        Exit Function
    End If
    
    ' Восстанавливаем состояние
    RestoreFromMemento this.memento
    
    ' Выполняем отмену
    ICommand_Undo = this.BaseCommand.OnUndo()
End Function

' Делегирование остальных методов ICommand базовому классу
Private Function ICommand_GetCommandName() As String
    ICommand_GetCommandName = this.BaseCommand.CommandName
End Function

Private Function ICommand_GetIdentifier() As String
    ICommand_GetIdentifier = this.BaseCommand.GetIdentifier()
End Function

Private Function ICommand_WasExecutedSuccessfully() As Boolean
    ICommand_WasExecutedSuccessfully = this.BaseCommand.WasExecutedSuccessfully()
End Function

Private Function ICommand_WasUndoneSuccessfully() As Boolean
    ICommand_WasUndoneSuccessfully = this.BaseCommand.WasUndoneSuccessfully()
End Function

Private Function ICommand_GetExecutionTimestamp() As Date
    ICommand_GetExecutionTimestamp = this.BaseCommand.GetExecutionTimestamp()
End Function

Private Function ICommand_GetUndoTimestamp() As Date
    ICommand_GetUndoTimestamp = this.BaseCommand.GetUndoTimestamp()
End Function

' Переопределяем методы базового класса
Public Function OnExecute() As Boolean
    ' Базовая реализация
    err.Raise 5, "UndoableCommand", "Метод OnExecute должен быть переопределен в наследнике"
    OnExecute = False
End Function

Public Function OnUndo() As Boolean
    ' Базовая реализация
    err.Raise 5, "UndoableCommand", "Метод OnUndo должен быть переопределен в наследнике"
    OnUndo = False
End Function

' Геттеры для доступа к защищенным свойствам
Public Property Get CommandName() As String
    CommandName = this.BaseCommand.CommandName
End Property

Public Property Get Logger() As Object
    Set Logger = this.BaseCommand.Logger
End Property

Public Property Get MementoCreated() As Boolean
    MementoCreated = this.MementoCreated
End Property


'-------------------------------------------
' Component: MementoCaretaker
'-------------------------------------------
' -----------------------------------------------------
' Класс: MementoCaretaker
' Описание: Хранитель снимков состояния для разных команд
' -----------------------------------------------------
Option Explicit

Private Type TMementoCaretaker
    Mementos As Object     ' Dictionary с ключами = ID команд и значениями = CommandMemento
    Logger As Object       ' Объект логгера
    MaxMementos As Long    ' Максимальное количество хранимых снимков
End Type

Private this As TMementoCaretaker

' Инициализация
Private Sub Class_Initialize()
    Set this.Mementos = CreateObject("Scripting.Dictionary")
    Set this.Logger = GetLogger()  ' Функция должна быть реализована в модуле
    this.MaxMementos = 100  ' По умолчанию храним до 100 снимков
End Sub

' Сохранение снимка состояния для команды
Public Sub SaveMemento(command As ICommand, memento As CommandMemento)
    If command Is Nothing Or memento Is Nothing Then Exit Sub
    
    Dim commandID As String
    commandID = command.GetIdentifier()
    
    ' Сохраняем снимок по ID команды
    If this.Mementos.Exists(commandID) Then
        this.Mementos.Remove commandID  ' Удаляем старый снимок если был
    End If
    
    this.Mementos.Add commandID, memento
    
    ' Проверяем количество снимков и удаляем старые при необходимости
    TrimMementos
    
    this.Logger.LogDebug "Сохранен снимок состояния для команды: " & command.GetCommandName(), "MementoCaretaker"
End Sub

' Получение снимка для команды
Public Function GetMemento(command As ICommand) As CommandMemento
    If command Is Nothing Then
        Set GetMemento = Nothing
        Exit Function
    End If
    
    Dim commandID As String
    commandID = command.GetIdentifier()
    
    ' Получаем снимок по ID команды
    If this.Mementos.Exists(commandID) Then
        Set GetMemento = this.Mementos(commandID)
    Else
        Set GetMemento = Nothing
        this.Logger.LogWarning "Снимок состояния не найден для команды: " & command.GetCommandName(), "MementoCaretaker"
    End If
End Function

' Очистка всех снимков
Public Sub ClearMementos()
    Set this.Mementos = CreateObject("Scripting.Dictionary")
    this.Logger.LogInfo "Все снимки состояний очищены", "MementoCaretaker"
End Sub

' Удаление снимка для команды
Public Sub RemoveMemento(command As ICommand)
    If command Is Nothing Then Exit Sub
    
    Dim commandID As String
    commandID = command.GetIdentifier()
    
    If this.Mementos.Exists(commandID) Then
        this.Mementos.Remove commandID
        this.Logger.LogDebug "Удален снимок состояния для команды: " & command.GetCommandName(), "MementoCaretaker"
    End If
End Sub

' Получение количества хранимых снимков
Public Function GetMementoCount() As Long
    GetMementoCount = this.Mementos.count
End Function

' Установка максимального количества снимков
Public Property Let MaxMementos(value As Long)
    this.MaxMementos = value
    TrimMementos  ' Применяем ограничение сразу
End Property

' Получение максимального количества снимков
Public Property Get MaxMementos() As Long
    MaxMementos = this.MaxMementos
End Property

' Внутренний метод для удаления старых снимков
Private Sub TrimMementos()
    ' Если количество снимков не превышает максимум, ничего не делаем
    If this.Mementos.count <= this.MaxMementos Then Exit Sub
    
    ' Сортируем снимки по времени создания
    Dim sortedKeys() As String
    Dim sortedDates() As Date
    Dim i As Long, j As Long, count As Long
    
    ' Получаем количество элементов
    count = this.Mementos.count
    
    ' Инициализируем массивы
    ReDim sortedKeys(1 To count)
    ReDim sortedDates(1 To count)
    
    ' Заполняем массивы
    i = 1
    Dim key As Variant
    For Each key In this.Mementos.Keys
        sortedKeys(i) = key
        sortedDates(i) = this.Mementos(key).GetTimestamp()
        i = i + 1
    Next key
    
    ' Сортируем по дате (простая пузырьковая сортировка)
    Dim tempKey As String
    Dim tempDate As Date
    
    For i = 1 To count - 1
        For j = i + 1 To count
            If sortedDates(i) > sortedDates(j) Then
                ' Меняем ключи местами
                tempKey = sortedKeys(i)
                sortedKeys(i) = sortedKeys(j)
                sortedKeys(j) = tempKey
                
                ' Меняем даты местами
                tempDate = sortedDates(i)
                sortedDates(i) = sortedDates(j)
                sortedDates(j) = tempDate
            End If
        Next j
    Next i
    
    ' Удаляем самые старые снимки, пока не достигнем максимума
    For i = 1 To (count - this.MaxMementos)
        If this.Mementos.Exists(sortedKeys(i)) Then
            this.Mementos.Remove sortedKeys(i)
        End If
    Next i
    
    this.Logger.LogDebug "Удалены старые снимки состояний для соблюдения лимита", "MementoCaretaker"
End Sub

'-------------------------------------------
' Component: CommandInvoker
'-------------------------------------------
' -----------------------------------------------------
' Класс: CommandInvoker
' Описание: Вызывает команды и отслеживает их историю
' -----------------------------------------------------
Option Explicit

Private Type TCommandInvoker
    CommandHistory As Collection    ' История выполненных команд
    MementoCaretaker As MementoCaretaker  ' Хранитель снимков состояния
    Logger As Object                ' Объект логгера
    errorHandler As Object          ' Объект для обработки ошибок
    LastError As String             ' Последняя ошибка
    MaxHistorySize As Long          ' Максимальный размер истории
    CurrentCommand As ICommand      ' Текущая команда
    mediator As Object              ' Медиатор для коммуникации
End Type

Private this As TCommandInvoker

' Инициализация
Private Sub Class_Initialize()
    Set this.CommandHistory = New Collection
    Set this.MementoCaretaker = New MementoCaretaker
    Set this.Logger = GetLogger()  ' Функция должна быть реализована в модуле
    Set this.errorHandler = GetErrorHandler()  ' Функция должна быть реализована в модуле
    this.LastError = ""
    this.MaxHistorySize = 50       ' По умолчанию храним 50 последних команд
    
    ' Пытаемся получить медиатор, если он существует
    On Error Resume Next
    Set this.mediator = GetMediator()
    On Error GoTo 0
End Sub

' Выполнение команды
Public Function Execute(command As ICommand) As Boolean
    On Error GoTo errorHandler
    
    ' Проверка входных данных
    If command Is Nothing Then
        this.LastError = "Команда не задана"
        this.Logger.LogError this.LastError, "CommandInvoker"
        Execute = False
        Exit Function
    End If
    
    ' Сохраняем текущую команду
    Set this.CurrentCommand = command
    
    ' Выполняем команду
    this.Logger.LogInfo "Выполнение команды: " & command.GetCommandName(), "CommandInvoker"
    
    ' Если команда поддерживает отмену через Memento, создаем снимок состояния
    If TypeOf command Is UndoableCommand Then
        ' Снимок создается внутри UndoableCommand при выполнении
    End If
    
    ' Выполняем команду
    Execute = command.Execute()
    
    ' Обрабатываем результат
    If Execute Then
        ' Добавляем в историю только успешно выполненные команды
        AddCommandToHistory command
        
        ' Уведомляем медиатор о выполнении команды
        NotifyCommandExecuted command, True
        
        this.Logger.LogInfo "Команда выполнена успешно", "CommandInvoker"
    Else
        this.LastError = "Команда не выполнена"
        
        ' Уведомляем медиатор о неудачном выполнении
        NotifyCommandExecuted command, False
        
        this.Logger.LogWarning "Команда не выполнена: " & command.GetCommandName(), "CommandInvoker"
    End If
    
    Exit Function
    
errorHandler:
    this.LastError = "Ошибка при выполнении команды: " & err.Description
    
    If Not this.errorHandler Is Nothing Then
        this.errorHandler.HandleError err, "Execute", command
    End If
    
    this.Logger.LogError this.LastError, "CommandInvoker"
    
    ' Уведомляем медиатор об ошибке
    NotifyCommandExecuted command, False
    
    Execute = False
End Function

' Отмена последней команды
Public Function UndoLastCommand() As Boolean
    On Error GoTo errorHandler
    
    ' Проверяем, есть ли команды в истории
    If this.CommandHistory.count = 0 Then
        this.LastError = "Нет команд для отмены"
        this.Logger.LogWarning this.LastError, "CommandInvoker"
        UndoLastCommand = False
        Exit Function
    End If
    
    ' Получаем последнюю команду из истории
    Dim lastCommand As ICommand
    Set lastCommand = this.CommandHistory(this.CommandHistory.count)
    
    ' Сохраняем текущую команду
    Set this.CurrentCommand = lastCommand
    
    ' Отменяем команду
    this.Logger.LogInfo "Отмена команды: " & lastCommand.GetCommandName(), "CommandInvoker"
    UndoLastCommand = lastCommand.Undo()
    
    ' Обрабатываем результат
    If UndoLastCommand Then
        ' Удаляем команду из истории
        this.CommandHistory.Remove this.CommandHistory.count
        
        ' Уведомляем медиатор об отмене
        NotifyCommandUndone lastCommand, True
        
        this.Logger.LogInfo "Команда отменена успешно", "CommandInvoker"
    Else
        this.LastError = "Не удалось отменить команду"
        
        ' Уведомляем медиатор о неудачной отмене
        NotifyCommandUndone lastCommand, False
        
        this.Logger.LogWarning "Не удалось отменить команду: " & lastCommand.GetCommandName(), "CommandInvoker"
    End If
    
    Exit Function
    
errorHandler:
    this.LastError = "Ошибка при отмене команды: " & err.Description
    
    If Not this.errorHandler Is Nothing Then
        this.errorHandler.HandleError err, "Undo", IIf(Not this.CurrentCommand Is Nothing, this.CurrentCommand, "Unknown")
    End If
    
    this.Logger.LogError this.LastError, "CommandInvoker"
    
    ' Уведомляем медиатор об ошибке
    If Not this.CurrentCommand Is Nothing Then
        NotifyCommandUndone this.CurrentCommand, False
    End If
    
    UndoLastCommand = False
End Function

' Получение истории команд
Public Function GetCommandHistory() As Collection
    Set GetCommandHistory = this.CommandHistory
End Function

' Получение количества команд в истории
Public Function GetHistoryCount() As Long
    GetHistoryCount = this.CommandHistory.count
End Function

' Очистка истории команд
Public Sub ClearHistory()
    Set this.CommandHistory = New Collection
    this.MementoCaretaker.ClearMementos
    this.Logger.LogInfo "История команд очищена", "CommandInvoker"
End Sub

' Добавление команды в историю
Private Sub AddCommandToHistory(command As ICommand)
    ' Добавляем команду в историю
    this.CommandHistory.Add command
    
    ' Проверяем размер истории и удаляем старые команды при необходимости
    TrimHistory
End Sub

' Усечение истории до максимального размера
Private Sub TrimHistory()
    ' Если размер не превышен, ничего не делаем
    If this.CommandHistory.count <= this.MaxHistorySize Then Exit Sub
    
    ' Удаляем самые старые команды
    While this.CommandHistory.count > this.MaxHistorySize
        this.CommandHistory.Remove 1
    Wend
    
    this.Logger.LogDebug "История команд усечена до максимального размера: " & this.MaxHistorySize, "CommandInvoker"
End Sub

' Получение текущей/последней команды
Public Property Get CurrentCommand() As ICommand
    Set CurrentCommand = this.CurrentCommand
End Property

' Получение последней ошибки
Public Property Get LastError() As String
    LastError = this.LastError
End Property

' Установка максимального размера истории
Public Property Let MaxHistorySize(value As Long)
    this.MaxHistorySize = value
    TrimHistory  ' Применяем ограничение сразу
End Property

' Получение максимального размера истории
Public Property Get MaxHistorySize() As Long
    MaxHistorySize = this.MaxHistorySize
End Property

' Отправка уведомления о выполнении команды через медиатор
Private Sub NotifyCommandExecuted(command As ICommand, success As Boolean)
    If this.mediator Is Nothing Then Exit Sub
    
    On Error Resume Next
    
    ' Создаем информацию о событии
    Dim data As Object
    Set data = CreateObject("Scripting.Dictionary")
    data.Add "Command", command
    data.Add "Success", success
    data.Add "CommandName", command.GetCommandName()
    If Not success Then data.Add "ErrorMessage", this.LastError
    
    ' Отправляем через медиатор
    this.mediator.NotifyCommandExecuted command, success
    
    On Error GoTo 0
End Sub

' Отправка уведомления об отмене команды через медиатор
Private Sub NotifyCommandUndone(command As ICommand, success As Boolean)
    If this.mediator Is Nothing Then Exit Sub
    
    On Error Resume Next
    
    ' Создаем информацию о событии
    Dim data As Object
    Set data = CreateObject("Scripting.Dictionary")
    data.Add "Command", command
    data.Add "Success", success
    data.Add "CommandName", command.GetCommandName()
    If Not success Then data.Add "ErrorMessage", this.LastError
    
    ' Отправляем через медиатор
    this.mediator.NotifyCommandUndone command, success
    
    On Error GoTo 0
End Sub

'-------------------------------------------
' Component: ValidationResult
'-------------------------------------------
' -----------------------------------------------------
' Класс: ValidationResult
' Описание: Хранит результаты валидации и ошибки
' -----------------------------------------------------
Option Explicit

Private Type TValidationResult
    Errors As Collection      ' Коллекция ошибок
    isValid As Boolean        ' Флаг валидности
End Type

Private this As TValidationResult

' Инициализация
Private Sub Class_Initialize()
    Set this.Errors = New Collection
    this.isValid = True  ' По умолчанию считаем валидным
End Sub

' Добавление ошибки
Public Sub AddError(message As String, Optional code As String = "")
    ' Создаем информацию об ошибке
    Dim errorInfo As Object
    Set errorInfo = CreateObject("Scripting.Dictionary")
    
    ' Заполняем информацию
    errorInfo.Add "message", message
    errorInfo.Add "code", code
    errorInfo.Add "timestamp", Now
    
    ' Добавляем в коллекцию
    this.Errors.Add errorInfo
    
    ' Отмечаем, что валидация не прошла
    this.isValid = False
End Sub

' Проверка валидности
Public Property Get isValid() As Boolean
    isValid = this.isValid
End Property

' Проверка наличия ошибок
Public Function HasErrors() As Boolean
    HasErrors = (this.Errors.count > 0)
End Function

' Получение количества ошибок
Public Function GetErrorCount() As Long
    GetErrorCount = this.Errors.count
End Function

' Получение всех ошибок в виде коллекции
Public Function GetErrors() As Collection
    Set GetErrors = this.Errors
End Function

' Получение всех ошибок в виде строки
Public Function GetErrorsAsString() As String
    Dim result As String
    result = ""
    
    Dim i As Long
    Dim errorInfo As Object
    
    For i = 1 To this.Errors.count
        Set errorInfo = this.Errors(i)
        
        ' Добавляем разделитель строк, если это не первая ошибка
        If Len(result) > 0 Then
            result = result & vbCrLf
        End If
        
        ' Добавляем код ошибки, если он есть
        If Len(errorInfo("code")) > 0 Then
            result = result & "[" & errorInfo("code") & "] "
        End If
        
        ' Добавляем сообщение об ошибке
        result = result & errorInfo("message")
    Next i
    
    GetErrorsAsString = result
End Function

' Объединение с другим результатом валидации
Public Sub MergeWith(otherResult As ValidationResult)
    If otherResult Is Nothing Then Exit Sub
    
    ' Если другой результат содержит ошибки, добавляем их
    If otherResult.HasErrors() Then
        Dim otherErrors As Collection
        Set otherErrors = otherResult.GetErrors()
        
        Dim i As Long
        For i = 1 To otherErrors.count
            this.Errors.Add otherErrors(i)
        Next i
        
        ' Отмечаем, что валидация не прошла
        this.isValid = False
    End If
End Sub

' Очистка всех ошибок
Public Sub ClearErrors()
    Set this.Errors = New Collection
    this.isValid = True
End Sub

'-------------------------------------------
' Component: ValidationRule
'-------------------------------------------
' -----------------------------------------------------
' Класс: ValidationRule
' Описание: Базовый класс для правил валидации
' -----------------------------------------------------
Option Explicit

' Внутренняя структура для данных
Private Type TValidationRule
    ErrorMessage As String    ' Сообщение об ошибке
    errorCode As String       ' Код ошибки
    Logger As Object          ' Объект логгера
End Type

Private this As TValidationRule

' Инициализация
Private Sub Class_Initialize()
    this.ErrorMessage = "Ошибка валидации"
    this.errorCode = "VALIDATION_ERROR"
    Set this.Logger = GetLogger()  ' Функция должна быть реализована в модуле
End Sub

' Установка сообщения об ошибке
Public Sub SetErrorMessage(message As String)
    this.ErrorMessage = message
End Sub

' Установка кода ошибки
Public Sub SetErrorCode(code As String)
    this.errorCode = code
End Sub

' Валидация объекта
Public Function Validate(entity As Object) As Boolean
    ' Базовая реализация (всегда проходит валидацию)
    ' Должна быть переопределена в наследниках
    Validate = True
End Function

' Получение сообщения об ошибке
Public Function GetErrorMessage() As String
    GetErrorMessage = this.ErrorMessage
End Function

' Получение кода ошибки
Public Function GetErrorCode() As String
    GetErrorCode = this.errorCode
End Function

' Валидация с сохранением результата
Public Function ValidateWithResult(entity As Object, result As ValidationResult) As Boolean
    ' Выполняем валидацию
    Dim isValid As Boolean
    isValid = Validate(entity)
    
    ' Если валидация не прошла, добавляем ошибку в результат
    If Not isValid And Not result Is Nothing Then
        result.AddError GetErrorMessage(), GetErrorCode()
    End If
    
    ' Возвращаем результат валидации
    ValidateWithResult = isValid
End Function

' Логирование результата валидации
Private Sub LogValidationResult(isValid As Boolean, context As String)
    If isValid Then
        this.Logger.LogDebug "Валидация успешна: " & context, "ValidationRule"
    Else
        this.Logger.LogWarning "Ошибка валидации: " & this.ErrorMessage & " (" & context & ")", "ValidationRule"
    End If
End Sub

'-------------------------------------------
' Component: CompositeValidationRule
'-------------------------------------------
' -----------------------------------------------------
' Класс: CompositeValidationRule
' Описание: Составное правило, объединяющее несколько правил
' -----------------------------------------------------
Option Explicit

' Внутренняя структура для данных
Private Type TCompositeValidationRule
    Rules As Collection       ' Коллекция правил
    ErrorMessage As String    ' Сообщение об ошибке
    errorCode As String       ' Код ошибки
    StopOnFirstFailure As Boolean ' Остановка при первой ошибке
    Logger As Object          ' Объект логгера
End Type

Private this As TCompositeValidationRule

' Инициализация
Private Sub Class_Initialize()
    Set this.Rules = New Collection
    this.ErrorMessage = "Составное правило: ошибка валидации"
    this.errorCode = "COMPOSITE_VALIDATION_ERROR"
    this.StopOnFirstFailure = False ' По умолчанию проверяем все правила
    Set this.Logger = GetLogger()  ' Функция должна быть реализована в модуле
End Sub

' Добавление правила
Public Sub AddRule(rule As ValidationRule)
    If rule Is Nothing Then Exit Sub
    this.Rules.Add rule
End Sub

' Получение количества правил
Public Function GetRuleCount() As Long
    GetRuleCount = this.Rules.count
End Function

' Установка опции остановки при первой ошибке
Public Property Let StopOnFirstFailure(value As Boolean)
    this.StopOnFirstFailure = value
End Property

' Получение опции остановки при первой ошибке
Public Property Get StopOnFirstFailure() As Boolean
    StopOnFirstFailure = this.StopOnFirstFailure
End Property

' Валидация объекта
Public Function Validate(entity As Object) As Boolean
    ' Если нет правил, считаем валидным
    If this.Rules.count = 0 Then
        Validate = True
        Exit Function
    End If
    
    ' Результат по умолчанию - валидный
    Validate = True
    
    ' Проверяем каждое правило
    Dim i As Long
    Dim rule As ValidationRule
    Dim ruleResult As Boolean
    
    For i = 1 To this.Rules.count
        Set rule = this.Rules(i)
        
        ' Проверяем правило
        ruleResult = rule.Validate(entity)
        
        ' Если правило не прошло
        If Not ruleResult Then
            ' Отмечаем, что валидация не прошла
            Validate = False
            
            ' Логируем ошибку
            this.Logger.LogDebug "Правило не прошло: " & rule.GetErrorMessage(), "CompositeValidationRule"
            
            ' Если настроена остановка при первой ошибке, выходим
            If this.StopOnFirstFailure Then Exit For
        End If
    Next i
    
    ' Логируем общий результат
    If Validate Then
        this.Logger.LogDebug "Составное правило: все проверки прошли успешно", "CompositeValidationRule"
    Else
        this.Logger.LogWarning "Составное правило: некоторые проверки не прошли", "CompositeValidationRule"
    End If
    
    ' Возвращаем результат валидации
    Validate = Validate
End Function

' Валидация с сохранением результата
Public Function ValidateWithResult(entity As Object, result As ValidationResult) As Boolean
    ' Если нет правил или результата, считаем валидным
    If this.Rules.count = 0 Or result Is Nothing Then
        ValidateWithResult = True
        Exit Function
    End If
    
    ' Результат по умолчанию - валидный
    ValidateWithResult = True
    
    ' Проверяем каждое правило
    Dim i As Long
    Dim rule As ValidationRule
    Dim ruleResult As Boolean
    
    For i = 1 To this.Rules.count
        Set rule = this.Rules(i)
        
        ' Проверяем правило и сохраняем результат
        ruleResult = rule.ValidateWithResult(entity, result)
        
        ' Если правило не прошло
        If Not ruleResult Then
            ' Отмечаем, что валидация не прошла
            ValidateWithResult = False
            
            ' Если настроена остановка при первой ошибке, выходим
            If this.StopOnFirstFailure Then Exit For
        End If
    Next i
    
    ' Возвращаем результат валидации
    ValidateWithResult = ValidateWithResult
End Function

' Получение сообщения об ошибке
Public Function GetErrorMessage() As String
    ' Если нет ошибок или правил, возвращаем стандартное сообщение
    If this.Rules.count = 0 Then
        GetErrorMessage = this.ErrorMessage
        Exit Function
    End If
    
    ' Собираем сообщения от всех невалидных правил
    Dim result As String
    result = ""
    
    Dim i As Long
    Dim rule As ValidationRule
    
    For i = 1 To this.Rules.count
        Set rule = this.Rules(i)
        
        ' Проверяем правило
        If Not rule.Validate(Nothing) Then  ' Мы уже знаем, что правило не прошло, поэтому передаем Nothing
            ' Добавляем разделитель строк, если это не первая ошибка
            If Len(result) > 0 Then
                result = result & vbCrLf
            End If
            
            ' Добавляем сообщение об ошибке
            result = result & "- " & rule.GetErrorMessage()
        End If
    Next i
    
    ' Если нет сообщений (все правила прошли), возвращаем стандартное сообщение
    If Len(result) = 0 Then
        GetErrorMessage = this.ErrorMessage
    Else
        GetErrorMessage = this.ErrorMessage & ":" & vbCrLf & result
    End If
End Function

' Получение кода ошибки
Public Function GetErrorCode() As String
    GetErrorCode = this.errorCode
End Function

'-------------------------------------------
' Component: ExcelCommand
'-------------------------------------------
' -----------------------------------------------------
' Класс: ExcelCommand
' Описание: Базовый класс для команд Excel с общей функциональностью
' -----------------------------------------------------
Option Explicit

' Наследуем от UndoableCommand и добавляем валидацию
Implements ICommand

Private Type TExcelCommand
    BaseCommand As UndoableCommand  ' Базовая команда с поддержкой отмены
    sheetName As String             ' Имя листа
    cellAddress As String           ' Адрес ячейки
    ExcelApp As Object              ' Ссылка на приложение Excel
    IsInitialized As Boolean        ' Флаг инициализации
    ValidationResult As ValidationResult ' Результат валидации
End Type

Private this As TExcelCommand

' Инициализация
Private Sub Class_Initialize()
    Set this.BaseCommand = New UndoableCommand
    Set this.ValidationResult = New ValidationResult
    
    ' Получаем приложение Excel
    Set this.ExcelApp = Application
    
    this.IsInitialized = False
End Sub

' Основные методы

Public Sub Initialize(sheetName As String, cellAddress As String)
    ' Инициализируем базовую команду
    this.BaseCommand.InitializeBase TypeName(Me)
    
    ' Сохраняем параметры
    this.sheetName = sheetName
    this.cellAddress = cellAddress
    
    this.IsInitialized = True
End Sub

' Валидация перед выполнением
Public Function Validate() As Boolean
    ' Очищаем результаты предыдущей валидации
    Set this.ValidationResult = New ValidationResult
    
    ' Проверяем инициализацию
    If Not this.IsInitialized Then
        this.ValidationResult.AddError "Команда не инициализирована", "COMMAND_NOT_INITIALIZED"
        Validate = False
        Exit Function
    End If
    
    ' Проверяем имя листа
    If Not ValidateSheetName(this.ValidationResult) Then
        Validate = False
        Exit Function
    End If
    
    ' Проверяем адрес ячейки
    If Not ValidateCellAddress(this.ValidationResult) Then
        Validate = False
        Exit Function
    End If
    
    ' Дополнительная валидация в наследниках
    If Not DoValidate(this.ValidationResult) Then
        Validate = False
        Exit Function
    End If
    
    Validate = this.ValidationResult.isValid
End Function

' Метод для переопределения в наследниках - дополнительная валидация
Private Function DoValidate(result As ValidationResult) As Boolean
    ' Базовая реализация - всегда успешно
    DoValidate = True
End Function

' Валидация имени листа
Private Function ValidateSheetName(result As ValidationResult) As Boolean
    ' Проверка на пустое имя
    If Len(this.sheetName) = 0 Then
        result.AddError "Имя листа не может быть пустым", "EMPTY_SHEET_NAME"
        ValidateSheetName = False
        Exit Function
    End If
    
    ' Проверка существования листа
    Dim ws As Object
    On Error Resume Next
    Set ws = this.ExcelApp.Worksheets(this.sheetName)
    
    If ws Is Nothing Or err.Number <> 0 Then
        result.AddError "Лист '" & this.sheetName & "' не существует", "SHEET_NOT_FOUND"
        ValidateSheetName = False
        On Error GoTo 0
        Exit Function
    End If
    On Error GoTo 0
    
    ValidateSheetName = True
End Function

' Валидация адреса ячейки
Private Function ValidateCellAddress(result As ValidationResult) As Boolean
    ' Проверка на пустой адрес
    If Len(this.cellAddress) = 0 Then
        result.AddError "Адрес ячейки не может быть пустым", "EMPTY_CELL_ADDRESS"
        ValidateCellAddress = False
        Exit Function
    End If
    
    ' Проверка корректности адреса
    On Error Resume Next
    Dim ws As Worksheet
    Set ws = this.ExcelApp.Worksheets(this.sheetName)
    
    If Not ws Is Nothing Then
        Dim rng As Range
        Set rng = ws.Range(this.cellAddress)
        
        If rng Is Nothing Or err.Number <> 0 Then
            result.AddError "Недопустимый адрес ячейки: '" & this.cellAddress & "'", "INVALID_CELL_ADDRESS"
            ValidateCellAddress = False
            On Error GoTo 0
            Exit Function
        End If
    End If
    On Error GoTo 0
    
    ValidateCellAddress = True
End Function

'' Получение листа
'Private Function GetWorksheet() As Object
'    On Error Resume Next
'    Set GetWorksheet = this.ExcelApp.Worksheets(this.sheetName)
'    On Error GoTo 0
'End Function
'
'' Получение ячейки
'Private Function GetCell() As Object
'    Dim ws As Object
'    Set ws = GetWorksheet()
'
'    If Not ws Is Nothing Then
'        On Error Resume Next
'        Set GetCell = ws.Range(this.cellAddress)
'        On Error GoTo 0
'    End If
'End Function

' Реализация ICommand через делегирование

Private Function ICommand_Execute() As Boolean
    ' Проверяем валидность перед выполнением
    If Not Validate() Then
        ' Логируем ошибки валидации
        this.BaseCommand.Logger.LogWarning "Ошибки валидации: " & this.ValidationResult.GetErrorsAsString(), TypeName(Me)
        ICommand_Execute = False
        Exit Function
    End If
    
    ' Выполняем команду через базовую команду
    ICommand_Execute = this.BaseCommand.OnExecute()
End Function

Private Function ICommand_Undo() As Boolean
    ICommand_Undo = this.BaseCommand.OnUndo()
End Function

Private Function ICommand_GetCommandName() As String
    ICommand_GetCommandName = this.BaseCommand.CommandName
End Function

Private Function ICommand_GetIdentifier() As String
    ICommand_GetIdentifier = this.BaseCommand.GetIdentifier()
End Function

Private Function ICommand_WasExecutedSuccessfully() As Boolean
    ICommand_WasExecutedSuccessfully = this.BaseCommand.WasExecutedSuccessfully()
End Function

Private Function ICommand_WasUndoneSuccessfully() As Boolean
    ICommand_WasUndoneSuccessfully = this.BaseCommand.WasUndoneSuccessfully()
End Function

Private Function ICommand_GetExecutionTimestamp() As Date
    ICommand_GetExecutionTimestamp = this.BaseCommand.GetExecutionTimestamp()
End Function

Private Function ICommand_GetUndoTimestamp() As Date
    ICommand_GetUndoTimestamp = this.BaseCommand.GetUndoTimestamp()
End Function

' Getter-методы для доступа к защищенным свойствам
Public Property Get sheetName() As String
    sheetName = this.sheetName
End Property

Public Property Get cellAddress() As String
    cellAddress = this.cellAddress
End Property

Public Property Get ValidationResult() As ValidationResult
    Set ValidationResult = this.ValidationResult
End Property

Public Property Get Logger() As Object
    Set Logger = this.BaseCommand.Logger
End Property

Public Property Get IsInitialized() As Boolean
    IsInitialized = this.IsInitialized
End Property

' Методы для работы с Memento
Public Function SaveState() As Object
    Dim state As Object
    Set state = CreateObject("Scripting.Dictionary")
    
    ' Базовое сохранение состояния
    state.Add "SheetName", this.sheetName
    state.Add "CellAddress", this.cellAddress
    
    ' Дополнительные данные в наследниках
    Set SaveState = state
End Function

Public Sub RestoreState(stateData As Object)
    If TypeOf stateData Is Object  Then
        On Error Resume Next
        ' Восстанавливаем базовые параметры
        If stateData.Exists("SheetName") Then this.sheetName = stateData("SheetName")
        If stateData.Exists("CellAddress") Then this.cellAddress = stateData("CellAddress")
        On Error GoTo 0
    End If
End Sub

' В классе ExcelCommand.cls добавьте публичный метод Execute:
Public Function Execute() As Boolean
    ' Выполняем валидацию и другую логику
    If Not Validate() Then
        Logger.LogWarning "Команда невалидна: " & ValidationResult.GetErrorsAsString(), TypeName(Me)
        Execute = False
        Exit Function
    End If
    
    ' Вызываем абстрактный метод OnExecute()
    Execute = OnExecute()
End Function

' Добавьте в класс ExcelCommand
Public Function OnExecute() As Boolean
    ' Базовая реализация для переопределения в наследниках
    err.Raise 5, "ExcelCommand", "Метод OnExecute должен быть переопределен в наследнике"
    OnExecute = False
End Function

' Добавьте в класс ExcelCommand
Public Function GetCell() As Object
    On Error Resume Next
    
    ' Получаем лист
    Dim ws As Object
    Set ws = GetWorksheet()
    
    ' Получаем ячейку
    If Not ws Is Nothing Then
        Set GetCell = ws.Range(this.cellAddress)
    End If
    
    If err.Number <> 0 Then
        Logger.LogError "Ошибка при получении ячейки: " & err.Description, "ExcelCommand"
    End If
    
    On Error GoTo 0
End Function

' Убедитесь, что также есть метод GetWorksheet
Public Function GetWorksheet() As Object
    On Error Resume Next
    
    ' Получаем приложение Excel и лист
    Set GetWorksheet = Application.Worksheets(this.sheetName)
    
    If err.Number <> 0 Then
        Logger.LogError "Ошибка при получении листа: " & err.Description, "ExcelCommand"
    End If
    
    On Error GoTo 0
End Function

'-------------------------------------------
' Component: SetCellValueCommand
'-------------------------------------------
' -----------------------------------------------------
' Класс: SetCellValueCommand
' Описание: Команда для установки значения ячейки
' -----------------------------------------------------
Option Explicit

' Наследуем от ExcelCommand
Implements ICommand

Private Type TSetCellValueCommand
    ExcelCommand As ExcelCommand    ' Базовая команда Excel
    NewValue As Variant             ' Новое значение ячейки
    OldValue As Variant             ' Старое значение ячейки (для отмены)
End Type

Private this As TSetCellValueCommand

' Инициализация
Private Sub Class_Initialize()
    Set this.ExcelCommand = New ExcelCommand
End Sub

' Инициализация команды
Public Sub Initialize(sheetName As String, cellAddress As String, NewValue As Variant)
    ' Инициализируем базовую команду
    this.ExcelCommand.Initialize sheetName, cellAddress
    
    ' Сохраняем новое значение
    this.NewValue = NewValue
    
    ' Старое значение будет получено при выполнении
End Sub

' Переопределение выполнения команды
Public Function OnExecute() As Boolean
    On Error GoTo errorHandler
    
    ' Получаем ячейку
    Dim cell As Object
    Set cell = this.ExcelCommand.GetCell()
    
    If cell Is Nothing Then
        this.ExcelCommand.Logger.LogError "Не удалось получить ячейку", "SetCellValueCommand"
        OnExecute = False
        Exit Function
    End If
    
    ' Сохраняем старое значение для отмены
    this.OldValue = cell.value
    
    ' Устанавливаем новое значение
    cell.value = this.NewValue
    
    this.ExcelCommand.Logger.LogInfo "Значение в ячейке " & this.ExcelCommand.sheetName & "!" & _
                                    this.ExcelCommand.cellAddress & " изменено с '" & _
                                    this.OldValue & "' на '" & this.NewValue & "'", "SetCellValueCommand"
    
    OnExecute = True
    Exit Function
    
errorHandler:
    this.ExcelCommand.Logger.LogError "Ошибка при установке значения ячейки: " & err.Description, "SetCellValueCommand"
    OnExecute = False
End Function

' Переопределение отмены команды
Public Function OnUndo() As Boolean
    On Error GoTo errorHandler
    
    ' Получаем ячейку
    Dim cell As Object
    Set cell = this.ExcelCommand.GetCell()
    
    If cell Is Nothing Then
        this.ExcelCommand.Logger.LogError "Не удалось получить ячейку для отмены", "SetCellValueCommand"
        OnUndo = False
        Exit Function
    End If
    
    ' Восстанавливаем старое значение
    cell.value = this.OldValue
    
    this.ExcelCommand.Logger.LogInfo "Значение в ячейке " & this.ExcelCommand.sheetName & "!" & _
                                    this.ExcelCommand.cellAddress & " возвращено к '" & _
                                    this.OldValue & "'", "SetCellValueCommand"
    
    OnUndo = True
    Exit Function
    
errorHandler:
    this.ExcelCommand.Logger.LogError "Ошибка при отмене изменения значения ячейки: " & err.Description, "SetCellValueCommand"
    OnUndo = False
End Function

' Дополнительная валидация для этой команды
Public Function DoValidate(result As ValidationResult) As Boolean
    ' Базовая реализация - без дополнительной валидации
    DoValidate = True
End Function

' Реализация ICommand через делегирование ExcelCommand
' В классе SetCellValueCommand исправьте метод ICommand_Execute:
Private Function ICommand_Execute() As Boolean
    ' Проверяем валидность перед выполнением
    If Not this.ExcelCommand.Validate() Then
        this.ExcelCommand.Logger.LogWarning "Невалидная команда: " & this.ExcelCommand.ValidationResult.GetErrorsAsString(), TypeName(Me)
        ICommand_Execute = False
        Exit Function
    End If
    
    ' Вызываем OnExecute напрямую
    ICommand_Execute = OnExecute()
End Function

Private Function ICommand_Undo() As Boolean
    ICommand_Undo = this.ExcelCommand.Undo()
End Function

Private Function ICommand_GetCommandName() As String
    ICommand_GetCommandName = "SetCellValue"
End Function

Private Function ICommand_GetIdentifier() As String
    ICommand_GetIdentifier = this.ExcelCommand.GetIdentifier()
End Function

Private Function ICommand_WasExecutedSuccessfully() As Boolean
    ICommand_WasExecutedSuccessfully = this.ExcelCommand.WasExecutedSuccessfully()
End Function

Private Function ICommand_WasUndoneSuccessfully() As Boolean
    ICommand_WasUndoneSuccessfully = this.ExcelCommand.WasUndoneSuccessfully()
End Function

Private Function ICommand_GetExecutionTimestamp() As Date
    ICommand_GetExecutionTimestamp = this.ExcelCommand.GetExecutionTimestamp()
End Function

Private Function ICommand_GetUndoTimestamp() As Date
    ICommand_GetUndoTimestamp = this.ExcelCommand.GetUndoTimestamp()
End Function

' Методы для работы с Memento
Public Function SaveState() As Object
    ' Получаем базовое состояние
    Dim state As Object
    Set state = this.ExcelCommand.SaveState()
    
    ' Добавляем специфичные данные
    state.Add "OldValue", this.OldValue
    state.Add "NewValue", this.NewValue
    
    Set SaveState = state
End Function

Public Sub RestoreState(stateData As Object)
    ' Восстанавливаем базовое состояние
    this.ExcelCommand.RestoreState stateData
    
    ' Восстанавливаем специфичные данные
    If TypeOf stateData Is Object  Then
        On Error Resume Next
        If stateData.Exists("OldValue") Then this.OldValue = stateData("OldValue")
        If stateData.Exists("NewValue") Then this.NewValue = stateData("NewValue")
        On Error GoTo 0
    End If
End Sub

' Свойства доступа
Public Property Get NewValue() As Variant
    NewValue = this.NewValue
End Property

Public Property Get OldValue() As Variant
    OldValue = this.OldValue
End Property

Public Property Get ValidationResult() As ValidationResult
    Set ValidationResult = this.ExcelCommand.ValidationResult
End Property

Public Property Get sheetName() As String
    sheetName = this.ExcelCommand.sheetName
End Property

Public Property Get cellAddress() As String
    cellAddress = this.ExcelCommand.cellAddress
End Property


'-------------------------------------------
' Component: SetCellColorCommand
'-------------------------------------------
' -----------------------------------------------------
' Класс: SetCellColorCommand
' Описание: Команда для установки цвета фона ячейки
' -----------------------------------------------------
Option Explicit

' Наследуем от ExcelCommand
Implements ICommand

Private Type TSetCellColorCommand
    ExcelCommand As ExcelCommand    ' Базовая команда Excel
    NewColor As Long                ' Новый цвет фона ячейки
    OldColor As Long                ' Старый цвет фона ячейки (для отмены)
End Type

Private this As TSetCellColorCommand

' Инициализация
Private Sub Class_Initialize()
    Set this.ExcelCommand = New ExcelCommand
End Sub

' Инициализация команды
Public Sub Initialize(sheetName As String, cellAddress As String, NewColor As Long)
    ' Инициализируем базовую команду
    this.ExcelCommand.Initialize sheetName, cellAddress
    
    ' Сохраняем новый цвет
    this.NewColor = NewColor
    
    ' Старый цвет будет получен при выполнении
End Sub

' Переопределение выполнения команды
Public Function OnExecute() As Boolean
    On Error GoTo errorHandler
    
    ' Получаем ячейку
    Dim cell As Object
    Set cell = this.ExcelCommand.GetCell()
    
    If cell Is Nothing Then
        this.ExcelCommand.Logger.LogError "Не удалось получить ячейку", "SetCellColorCommand"
        OnExecute = False
        Exit Function
    End If
    
    ' Сохраняем старый цвет для отмены
    this.OldColor = cell.Interior.color
    
    ' Устанавливаем новый цвет
    cell.Interior.color = this.NewColor
    
    this.ExcelCommand.Logger.LogInfo "Цвет фона в ячейке " & this.ExcelCommand.sheetName & "!" & _
                                   this.ExcelCommand.cellAddress & " изменен с #" & _
                                   Hex(this.OldColor) & " на #" & Hex(this.NewColor), "SetCellColorCommand"
    
    OnExecute = True
    Exit Function
    
errorHandler:
    this.ExcelCommand.Logger.LogError "Ошибка при установке цвета фона ячейки: " & err.Description, "SetCellColorCommand"
    OnExecute = False
End Function

' Переопределение отмены команды
Public Function OnUndo() As Boolean
    On Error GoTo errorHandler
    
    ' Получаем ячейку
    Dim cell As Object
    Set cell = this.ExcelCommand.GetCell()
    
    If cell Is Nothing Then
        this.ExcelCommand.Logger.LogError "Не удалось получить ячейку для отмены", "SetCellColorCommand"
        OnUndo = False
        Exit Function
    End If
    
    ' Восстанавливаем старый цвет
    cell.Interior.color = this.OldColor
    
    this.ExcelCommand.Logger.LogInfo "Цвет фона в ячейке " & this.ExcelCommand.sheetName & "!" & _
                                   this.ExcelCommand.cellAddress & " возвращен к #" & _
                                   Hex(this.OldColor), "SetCellColorCommand"
    
    OnUndo = True
    Exit Function
    
errorHandler:
    this.ExcelCommand.Logger.LogError "Ошибка при отмене изменения цвета фона ячейки: " & err.Description, "SetCellColorCommand"
    OnUndo = False
End Function

' Дополнительная валидация для этой команды
Public Function DoValidate(result As ValidationResult) As Boolean
    ' Можно добавить проверку корректности кода цвета
    DoValidate = True
End Function

' Реализация ICommand через делегирование ExcelCommand
Private Function ICommand_Execute() As Boolean
    ICommand_Execute = this.ExcelCommand.Execute()
End Function

Private Function ICommand_Undo() As Boolean
    ICommand_Undo = this.ExcelCommand.Undo()
End Function

Private Function ICommand_GetCommandName() As String
    ICommand_GetCommandName = "SetCellColor"
End Function

Private Function ICommand_GetIdentifier() As String
    ICommand_GetIdentifier = this.ExcelCommand.GetIdentifier()
End Function

Private Function ICommand_WasExecutedSuccessfully() As Boolean
    ICommand_WasExecutedSuccessfully = this.ExcelCommand.WasExecutedSuccessfully()
End Function

Private Function ICommand_WasUndoneSuccessfully() As Boolean
    ICommand_WasUndoneSuccessfully = this.ExcelCommand.WasUndoneSuccessfully()
End Function

Private Function ICommand_GetExecutionTimestamp() As Date
    ICommand_GetExecutionTimestamp = this.ExcelCommand.GetExecutionTimestamp()
End Function

Private Function ICommand_GetUndoTimestamp() As Date
    ICommand_GetUndoTimestamp = this.ExcelCommand.GetUndoTimestamp()
End Function

' Методы для работы с Memento
Public Function SaveState() As Object
    ' Получаем базовое состояние
    Dim state As Object
    Set state = this.ExcelCommand.SaveState()
    
    ' Добавляем специфичные данные
    state.Add "OldColor", this.OldColor
    state.Add "NewColor", this.NewColor
    
    Set SaveState = state
End Function

Public Sub RestoreState(stateData As Object)
    ' Восстанавливаем базовое состояние
    this.ExcelCommand.RestoreState stateData
    
    ' Восстанавливаем специфичные данные
    If TypeOf stateData Is Object  Then
        On Error Resume Next
        If stateData.Exists("OldColor") Then this.OldColor = stateData("OldColor")
        If stateData.Exists("NewColor") Then this.NewColor = stateData("NewColor")
        On Error GoTo 0
    End If
End Sub

' Свойства доступа
Public Property Get NewColor() As Long
    NewColor = this.NewColor
End Property

Public Property Get OldColor() As Long
    OldColor = this.OldColor
End Property

Public Property Get ValidationResult() As ValidationResult
    Set ValidationResult = this.ExcelCommand.ValidationResult
End Property

Public Property Get sheetName() As String
    sheetName = this.ExcelCommand.sheetName
End Property

Public Property Get cellAddress() As String
    cellAddress = this.ExcelCommand.cellAddress
End Property


'-------------------------------------------
' Component: LogLevels
'-------------------------------------------
' -----------------------------------------------------
' Модуль: LogLevel
' Описание: Определение уровней логирования
' -----------------------------------------------------
Option Explicit

' Уровни логирования
Public Enum logLevel
    LogDebug = 0     ' Отладочная информация
    LogInfo = 1      ' Информационные сообщения
    LogWarning = 2   ' Предупреждения
    LogError = 3     ' Ошибки
    LogCritical = 4  ' Критические ошибки
End Enum

' Получение строкового представления уровня
Public Function LogLevelToString(level As logLevel) As String
    Select Case level
        Case logLevel.LogDebug
            LogLevelToString = "DEBUG"
        Case logLevel.LogInfo
            LogLevelToString = "INFO"
        Case logLevel.LogWarning
            LogLevelToString = "WARNING"
        Case logLevel.LogError
            LogLevelToString = "ERROR"
        Case logLevel.LogCritical
            LogLevelToString = "CRITICAL"
        Case Else
            LogLevelToString = "UNKNOWN"
    End Select
End Function

'-------------------------------------------
' Component: LogEntry
'-------------------------------------------
' -----------------------------------------------------
' Класс: LogEntry
' Описание: Хранит информацию о записи в логе
' -----------------------------------------------------
Option Explicit

Private Type TLogEntry
    Timestamp As Date      ' Время записи
    level As logLevel      ' Уровень логирования
    message As String      ' Сообщение
    source As String       ' Источник (компонент, создавший запись)
End Type

Private this As TLogEntry

' Инициализация
Private Sub Class_Initialize()
    this.Timestamp = Now
    this.level = logLevel.LogInfo
    this.message = ""
    this.source = ""
End Sub

' Создание записи
Public Sub Create(level As logLevel, message As String, Optional source As String = "")
    this.Timestamp = Now
    this.level = level
    this.message = message
    this.source = source
End Sub

' Свойства доступа
Public Property Get Timestamp() As Date
    Timestamp = this.Timestamp
End Property

Public Property Let Timestamp(value As Date)
    this.Timestamp = value
End Property

Public Property Get level() As logLevel
    level = this.level
End Property

Public Property Let level(value As logLevel)
    this.level = value
End Property

Public Property Get message() As String
    message = this.message
End Property

Public Property Let message(value As String)
    this.message = value
End Property

Public Property Get source() As String
    source = this.source
End Property

Public Property Let source(value As String)
    this.source = value
End Property

' Получение строкового представления записи
Public Function ToString() As String
    Dim levelStr As String
    levelStr = LogLevelToString(this.level)
    
    ToString = Format(this.Timestamp, "yyyy-mm-dd hh:nn:ss") & " [" & levelStr & "] "
    
    If Len(this.source) > 0 Then
        ToString = ToString & "[" & this.source & "] "
    End If
    
    ToString = ToString & this.message
End Function

' Клонирование объекта
Public Function Clone() As LogEntry
    Dim result As New LogEntry
    
    result.Timestamp = this.Timestamp
    result.level = this.level
    result.message = this.message
    result.source = this.source
    
    Set Clone = result
End Function

'-------------------------------------------
' Component: Logger
'-------------------------------------------
' -----------------------------------------------------
' Класс: Logger
' Описание: Основной класс для логирования
' -----------------------------------------------------
Option Explicit

Private Type TLogger
    LogEntries As Collection   ' История записей
    MinLevel As logLevel       ' Минимальный уровень для записи
    MaxEntries As Long         ' Максимальное количество хранимых записей
    LogFileName As String      ' Имя файла для логирования
    EnableConsole As Boolean   ' Вывод в консоль
    EnableFile As Boolean      ' Вывод в файл
    mediator As Object         ' Медиатор для уведомлений
End Type

Private this As TLogger

' Инициализация
Private Sub Class_Initialize()
    Set this.LogEntries = New Collection
    this.MinLevel = logLevel.LogInfo  ' По умолчанию - INFO и выше
    this.MaxEntries = 1000            ' Храним до 1000 записей
    this.LogFileName = "log_" & Format(Date, "yyyymmdd") & ".txt"  ' Имя файла по умолчанию
    this.EnableConsole = True         ' Включен вывод в консоль
    this.EnableFile = False           ' Выключен вывод в файл
    
    ' Пытаемся получить медиатор, если он существует
    On Error Resume Next
    Set this.mediator = GetMediator()
    On Error GoTo 0
End Sub

' Основные методы
Public Sub Log(level As logLevel, message As String, Optional source As String = "")
    ' Проверяем уровень логирования
    If level < this.MinLevel Then Exit Sub
    
    ' Создаем запись
    Dim entry As New LogEntry
    entry.Create level, message, source
    
    ' Добавляем запись в историю
    this.LogEntries.Add entry
    TrimHistory  ' Удаляем старые записи при необходимости
    
    ' Выводим в консоль, если включено
    If this.EnableConsole Then
        Debug.Print entry.ToString()
    End If
    
    ' Записываем в файл, если включено
    If this.EnableFile Then
        WriteToFile entry
    End If
    
    ' Уведомляем через медиатор, если доступен
    If Not this.mediator Is Nothing Then
        On Error Resume Next
        this.mediator.NotifyLogEntryAdded entry
        On Error GoTo 0
    End If
End Sub

' Специализированные методы для разных уровней
Public Sub LogDebug(message As String, Optional source As String = "")
    Log logLevel.LogDebug, message, source
End Sub

Public Sub LogInfo(message As String, Optional source As String = "")
    Log logLevel.LogInfo, message, source
End Sub

Public Sub LogWarning(message As String, Optional source As String = "")
    Log logLevel.LogWarning, message, source
End Sub

Public Sub LogError(message As String, Optional source As String = "")
    Log logLevel.LogError, message, source
End Sub

Public Sub LogCritical(message As String, Optional source As String = "")
    Log logLevel.LogCritical, message, source
End Sub

' Запись в файл
Private Sub WriteToFile(entry As LogEntry)
    On Error Resume Next
    
    Dim fileNum As Integer
    fileNum = FreeFile
    
    ' Открываем файл в режиме добавления
    Open this.LogFileName For Append As #fileNum
    
    ' Записываем строку
    Print #fileNum, entry.ToString()
    
    ' Закрываем файл
    Close #fileNum
    
    On Error GoTo 0
End Sub

' Удаление старых записей
Private Sub TrimHistory()
    While this.LogEntries.count > this.MaxEntries
        this.LogEntries.Remove 1
    Wend
End Sub

' Свойства доступа

Public Property Get MinLevel() As logLevel
    MinLevel = this.MinLevel
End Property

Public Property Let MinLevel(value As logLevel)
    this.MinLevel = value
End Property

Public Property Get MaxEntries() As Long
    MaxEntries = this.MaxEntries
End Property

Public Property Let MaxEntries(value As Long)
    this.MaxEntries = value
    TrimHistory  ' Применяем ограничение сразу
End Property

Public Property Get LogFileName() As String
    LogFileName = this.LogFileName
End Property

Public Property Let LogFileName(value As String)
    this.LogFileName = value
End Property

Public Property Get EnableConsole() As Boolean
    EnableConsole = this.EnableConsole
End Property

Public Property Let EnableConsole(value As Boolean)
    this.EnableConsole = value
End Property

Public Property Get EnableFile() As Boolean
    EnableFile = this.EnableFile
End Property

Public Property Let EnableFile(value As Boolean)
    this.EnableFile = value
End Property

' Получение истории логов
Public Function GetLogHistory() As Collection
    Set GetLogHistory = this.LogEntries
End Function

' Очистка истории
Public Sub ClearHistory()
    Set this.LogEntries = New Collection
End Sub

' Получение количества записей
Public Function GetEntryCount() As Long
    GetEntryCount = this.LogEntries.count
End Function

' Установка медиатора
Public Property Set mediator(value As Object)
    Set this.mediator = value
End Property

'-------------------------------------------
' Component: LoggerModule
'-------------------------------------------
' -----------------------------------------------------
' Модуль: LoggerModule
' Описание: Глобальный доступ к логгеру
' -----------------------------------------------------
Option Explicit

' Экземпляр логгера
Private mLogger As Logger

' Получение экземпляра логгера
Public Function GetLogger() As Logger
    ' Создаем экземпляр, если еще не создан
    If mLogger Is Nothing Then
        Set mLogger = New Logger
        
        ' Настройки по умолчанию
        mLogger.MinLevel = logLevel.LogInfo
        mLogger.EnableConsole = True
        mLogger.EnableFile = False
    End If
    
    Set GetLogger = mLogger
End Function

' Сброс экземпляра логгера (для тестирования)
Public Sub ResetLogger()
    Set mLogger = Nothing
End Sub

'-------------------------------------------
' Component: ErrorInfo
'-------------------------------------------
' -----------------------------------------------------
' Класс: ErrorInfo
' Описание: Хранит информацию об ошибке
' -----------------------------------------------------
Option Explicit

Private Type TErrorInfo
    Number As Long           ' Номер ошибки
    Description As String    ' Описание ошибки
    source As String         ' Источник ошибки
    context As String        ' Контекст (метод, в котором произошла ошибка)
    CommandName As String    ' Имя команды (если ошибка связана с командой)
    Severity As Integer      ' Серьезность ошибки (1-5)
    Timestamp As Date        ' Время возникновения ошибки
    IsHandled As Boolean     ' Была ли ошибка обработана
End Type

Private this As TErrorInfo

' Инициализация
Private Sub Class_Initialize()
    this.Timestamp = Now
    this.Severity = 3  ' Средняя серьезность по умолчанию
    this.IsHandled = False
End Sub

' Создание из стандартного объекта ошибки
Public Sub CreateFromError(err As ErrObject, Optional context As String = "", Optional source As String = "")
    this.Number = err.Number
    this.Description = err.Description
    this.source = IIf(Len(source) > 0, source, err.source)
    this.context = context
    this.Timestamp = Now
End Sub

' Свойства доступа
Public Property Get Number() As Long
    Number = this.Number
End Property

Public Property Let Number(value As Long)
    this.Number = value
End Property

Public Property Get Description() As String
    Description = this.Description
End Property

Public Property Let Description(value As String)
    this.Description = value
End Property

Public Property Get source() As String
    source = this.source
End Property

Public Property Let source(value As String)
    this.source = value
End Property

Public Property Get context() As String
    context = this.context
End Property

Public Property Let context(value As String)
    this.context = value
End Property

Public Property Get CommandName() As String
    CommandName = this.CommandName
End Property

Public Property Let CommandName(value As String)
    this.CommandName = value
End Property

Public Property Get Severity() As Integer
    Severity = this.Severity
End Property

Public Property Let Severity(value As Integer)
    ' Ограничиваем серьезность диапазоном 1-5
    If value < 1 Then
        this.Severity = 1
    ElseIf value > 5 Then
        this.Severity = 5
    Else
        this.Severity = value
    End If
End Property

Public Property Get Timestamp() As Date
    Timestamp = this.Timestamp
End Property

Public Property Let Timestamp(value As Date)
    this.Timestamp = value
End Property

Public Property Get IsHandled() As Boolean
    IsHandled = this.IsHandled
End Property

Public Property Let IsHandled(value As Boolean)
    this.IsHandled = value
End Property

' Получение строкового представления ошибки
Public Function ToString() As String
    Dim result As String
    
    result = "Ошибка #" & this.Number & ": " & this.Description
    
    If Len(this.source) > 0 Then
        result = result & " | Источник: " & this.source
    End If
    
    If Len(this.context) > 0 Then
        result = result & " | Контекст: " & this.context
    End If
    
    If Len(this.CommandName) > 0 Then
        result = result & " | Команда: " & this.CommandName
    End If
    
    result = result & " | Серьезность: " & this.Severity
    result = result & " | Время: " & Format(this.Timestamp, "yyyy-mm-dd hh:nn:ss")
    
    ToString = result
End Function

' Клонирование объекта
Public Function Clone() As errorInfo
    Dim result As New errorInfo
    
    result.Number = this.Number
    result.Description = this.Description
    result.source = this.source
    result.context = this.context
    result.CommandName = this.CommandName
    result.Severity = this.Severity
    result.Timestamp = this.Timestamp
    result.IsHandled = this.IsHandled
    
    Set Clone = result
End Function

'-------------------------------------------
' Component: ErrorStrategy
'-------------------------------------------
' -----------------------------------------------------
' Класс: ErrorStrategy
' Описание: Базовый класс для стратегий обработки ошибок
' -----------------------------------------------------
Option Explicit

' Обработка ошибки
' Возвращает True, если ошибка была успешно обработана
Public Function HandleError(errorInfo As errorInfo) As Boolean
    ' Базовая реализация (должна быть переопределена в наследниках)
    HandleError = False
End Function

' Дополнительный метод для обработки стандартного объекта ошибки
Public Function HandleErrObject(err As ErrObject, context As String, Optional source As Object = Nothing) As Boolean
    ' Создаем объект ErrorInfo
    Dim errorInfo As New errorInfo
    
    ' Заполняем информацию об ошибке
    errorInfo.CreateFromError err, context, IIf(source Is Nothing, "", TypeName(source))
    
    ' Если источник - команда, добавляем имя команды
    If TypeOf source Is ICommand Then
        errorInfo.CommandName = source.GetCommandName()
    End If
    
    ' Обрабатываем ошибку через основной метод
    HandleErrObject = HandleError(errorInfo)
End Function

'-------------------------------------------
' Component: LoggingErrorStrategy
'-------------------------------------------
' -----------------------------------------------------
' Класс: LoggingErrorStrategy
' Описание: Стратегия обработки ошибок через логирование
' -----------------------------------------------------
Option Explicit

' Наследование от базовой стратегии
Private mLogger As Object  ' Будет Logger

' Инициализация
Private Sub Class_Initialize()
    Set mLogger = GetLogger()  ' Получаем экземпляр логгера
End Sub

' Переопределение метода обработки ошибки
Public Function HandleError(errorInfo As errorInfo) As Boolean
    ' Проверяем наличие логгера
    If mLogger Is Nothing Then
        Debug.Print "LoggingErrorStrategy: Логгер не найден"
        HandleError = False
        Exit Function
    End If
    
    ' Определяем уровень логирования в зависимости от серьезности ошибки
    Dim logLevel As logLevel
    Select Case errorInfo.Severity
        Case 1:
            logLevel = logLevel.LogDebug
        Case 2:
            logLevel = logLevel.LogInfo
        Case 3:
            logLevel = logLevel.LogWarning
        Case 4, 5:
            logLevel = logLevel.LogError
        Case Else:
            logLevel = logLevel.LogError
    End Select
    
    ' Логируем ошибку
    mLogger.Log logLevel, errorInfo.ToString(), "ErrorHandler"
    
    ' Отмечаем, что ошибка обработана
    errorInfo.IsHandled = True
    
    HandleError = True
End Function

'-------------------------------------------
' Component: DialogErrorStrategy
'-------------------------------------------
' -----------------------------------------------------
' Класс: DialogErrorStrategy
' Описание: Стратегия обработки ошибок через диалоговые окна
' -----------------------------------------------------
Option Explicit

' Наследование от базовой стратегии
Private mLogger As Object  ' Будет Logger

' Инициализация
Private Sub Class_Initialize()
    Set mLogger = GetLogger()  ' Получаем экземпляр логгера
End Sub

' Переопределение метода обработки ошибки
Public Function HandleError(errorInfo As errorInfo) As Boolean
    ' Определяем тип сообщения на основе серьезности ошибки
    Dim msgType As VbMsgBoxStyle
    
    Select Case errorInfo.Severity
        Case 1, 2:
            msgType = vbInformation
        Case 3:
            msgType = vbExclamation
        Case 4, 5:
            msgType = vbCritical
        Case Else:
            msgType = vbExclamation
    End Select
    
    ' Формируем заголовок
    Dim title As String
    title = "Ошибка"
    
    If Len(errorInfo.source) > 0 Then
        title = title & " в " & errorInfo.source
    End If
    
    ' Формируем сообщение
    Dim message As String
    message = errorInfo.Description
    
    If Len(errorInfo.context) > 0 Then
        message = message & vbCrLf & "Контекст: " & errorInfo.context
    End If
    
    If Len(errorInfo.CommandName) > 0 Then
        message = message & vbCrLf & "Команда: " & errorInfo.CommandName
    End If
    
    ' Выводим диалоговое окно
    MsgBox message, msgType, title
    
    ' Логируем для истории
    If Not mLogger Is Nothing Then
        mLogger.LogInfo "Отображено диалоговое окно с ошибкой: " & errorInfo.Number, "DialogErrorStrategy"
    End If
    
    ' Отмечаем, что ошибка обработана
    errorInfo.IsHandled = True
    
    HandleError = True
End Function

'-------------------------------------------
' Component: ErrorHandler
'-------------------------------------------
' -----------------------------------------------------
' Класс: ErrorHandler
' Описание: Централизованная обработка ошибок
' -----------------------------------------------------
Option Explicit

Private Type TErrorHandler
    DefaultStrategy As Object             ' Базовая стратегия
    ErrorStrategies As Object             ' Dictionary с ключами = коды ошибок, значения = стратегии
    Logger As Object                      ' Объект логгера
    mediator As Object                    ' Медиатор для уведомлений
    LastError As errorInfo                ' Последняя ошибка
    ErrorHistory As Collection            ' История ошибок
    MaxHistorySize As Long                ' Максимальный размер истории
End Type

Private this As TErrorHandler

' Инициализация
Private Sub Class_Initialize()
    ' Инициализируем стратегию по умолчанию
    Set this.DefaultStrategy = New LoggingErrorStrategy
    
    ' Создаем словарь для стратегий по кодам ошибок
    Set this.ErrorStrategies = CreateObject("Scripting.Dictionary")
    
    ' Создаем историю ошибок
    Set this.ErrorHistory = New Collection
    
    ' Устанавливаем максимальный размер истории
    this.MaxHistorySize = 100
    
    ' Получаем логгер
    Set this.Logger = GetLogger()
    
    ' Пытаемся получить медиатор, если он существует
    On Error Resume Next
    Set this.mediator = GetMediator()
    On Error GoTo 0
End Sub

' Основные методы

' Обработка объекта ошибки
Public Sub HandleError(err As ErrObject, context As String, Optional source As Object = Nothing)
    ' Создаем объект с информацией об ошибке
    Dim errorInfo As New errorInfo
    errorInfo.CreateFromError err, context, IIf(source Is Nothing, "", TypeName(source))
    
    ' Если источник - команда, добавляем имя команды
    If TypeOf source Is ICommand Then
        errorInfo.CommandName = source.GetCommandName()
    End If
    
    ' Обрабатываем ошибку
    HandleErrorInfo errorInfo
End Sub

' Обработка ошибки (через объект ErrorInfo)
Public Sub HandleErrorInfo(errorInfo As errorInfo)
    ' Сохраняем ошибку
    Set this.LastError = errorInfo.Clone()
    
    ' Добавляем в историю
    this.ErrorHistory.Add errorInfo.Clone()
    TrimHistory  ' Удаляем старые записи при необходимости
    
    ' Логируем ошибку
    If Not this.Logger Is Nothing Then
        this.Logger.LogError "Обработка ошибки: " & errorInfo.ToString(), "ErrorHandler"
    End If
    
    ' Находим подходящую стратегию
    Dim strategy As Object
    Set strategy = GetStrategyForError(errorInfo.Number)
    
    ' Применяем стратегию
    Dim handled As Boolean
    handled = strategy.HandleError(errorInfo)
    
    ' Уведомляем через медиатор, если доступен
    If Not this.mediator Is Nothing Then
        On Error Resume Next
        this.mediator.NotifyErrorOccurred errorInfo
        
        If handled Then
            this.mediator.NotifyErrorHandled errorInfo
        End If
        On Error GoTo 0
    End If
End Sub

' Получение стратегии для кода ошибки
Private Function GetStrategyForError(errorCode As Long) As Object
    Dim code As String
    code = CStr(errorCode)
    
    ' Проверяем, есть ли стратегия для конкретного кода
    If this.ErrorStrategies.Exists(code) Then
        Set GetStrategyForError = this.ErrorStrategies(code)
    Else
        ' Используем стратегию по умолчанию
        Set GetStrategyForError = this.DefaultStrategy
    End If
End Function

' Регистрация стратегии для конкретного кода ошибки
Public Sub RegisterStrategy(errorCode As Long, strategy As Object)
    Dim code As String
    code = CStr(errorCode)
    
    If this.ErrorStrategies.Exists(code) Then
        this.ErrorStrategies.Remove code
    End If
    
    this.ErrorStrategies.Add code, strategy
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Зарегистрирована стратегия для кода ошибки " & errorCode & ": " & TypeName(strategy), "ErrorHandler"
    End If
End Sub

' Установка стратегии по умолчанию
Public Property Set DefaultStrategy(strategy As Object)
    Set this.DefaultStrategy = strategy
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Установлена стратегия по умолчанию: " & TypeName(strategy), "ErrorHandler"
    End If
End Property

' Удаление старых записей
Private Sub TrimHistory()
    While this.ErrorHistory.count > this.MaxHistorySize
        this.ErrorHistory.Remove 1
    Wend
End Sub

' Свойства доступа
Public Property Get LastError() As errorInfo
    Set LastError = this.LastError
End Property

Public Property Get ErrorHistory() As Collection
    Set ErrorHistory = this.ErrorHistory
End Property

Public Property Let MaxHistorySize(value As Long)
    this.MaxHistorySize = value
    TrimHistory  ' Применяем ограничение сразу
End Property

Public Property Get MaxHistorySize() As Long
    MaxHistorySize = this.MaxHistorySize
End Property

' Очистка истории ошибок
Public Sub ClearHistory()
    Set this.ErrorHistory = New Collection
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "История ошибок очищена", "ErrorHandler"
    End If
End Sub

'-------------------------------------------
' Component: CommandEvent
'-------------------------------------------
' -----------------------------------------------------
' Класс: CommandEvent
' Описание: Событие, связанное с выполнением/отменой команды
' -----------------------------------------------------
Option Explicit

Private Type TCommandEvent
    baseEvent As EventBase   ' Базовое событие
    command As Object        ' Команда (ICommand)
    success As Boolean       ' Успех операции
    ErrorMessage As String   ' Сообщение об ошибке (если не успешно)
End Type

Private this As TCommandEvent

' Инициализация
Private Sub Class_Initialize()
    Set this.baseEvent = New EventBase
    this.success = True
    this.ErrorMessage = ""
End Sub

' Инициализация с параметрами для выполнения команды
Public Sub InitializeExecuted(command As Object, success As Boolean, Optional ErrorMessage As String = "")
    this.baseEvent.Initialize EVENT_COMMAND_EXECUTED, TypeName(Me)
    Set this.command = command
    this.success = success
    this.ErrorMessage = ErrorMessage
End Sub

' Инициализация с параметрами для отмены команды
Public Sub InitializeUndone(command As Object, success As Boolean, Optional ErrorMessage As String = "")
    this.baseEvent.Initialize EVENT_COMMAND_UNDONE, TypeName(Me)
    Set this.command = command
    this.success = success
    this.ErrorMessage = ErrorMessage
End Sub

' Свойства доступа
Public Property Get eventType() As String
    eventType = this.baseEvent.eventType
End Property

Public Property Get Timestamp() As Date
    Timestamp = this.baseEvent.Timestamp
End Property

Public Property Get source() As String
    source = this.baseEvent.source
End Property

Public Property Get command() As Object
    Set command = this.command
End Property

Public Property Get success() As Boolean
    success = this.success
End Property

Public Property Get ErrorMessage() As String
    ErrorMessage = this.ErrorMessage
End Property

' Клонирование объекта
Public Function Clone() As CommandEvent
    Dim result As New CommandEvent
    
    ' Копируем базовое событие
    result.baseEvent.eventType = this.baseEvent.eventType
    result.baseEvent.Timestamp = this.baseEvent.Timestamp
    result.baseEvent.source = this.baseEvent.source
    
    ' Копируем специфичные свойства
    Set result.command = this.command
    result.success = this.success
    result.ErrorMessage = this.ErrorMessage
    
    Set Clone = result
End Function

'-------------------------------------------
' Component: ErrorHandlerModule
'-------------------------------------------
' -----------------------------------------------------
' Модуль: ErrorHandlerModule
' Описание: Глобальный доступ к обработчику ошибок
' -----------------------------------------------------
Option Explicit

' Экземпляр обработчика ошибок
Private mErrorHandler As errorHandler

' Получение экземпляра обработчика ошибок
Public Function GetErrorHandler() As errorHandler
    ' Создаем экземпляр, если еще не создан
    If mErrorHandler Is Nothing Then
        Set mErrorHandler = New errorHandler
    End If
    
    Set GetErrorHandler = mErrorHandler
End Function

' Сброс экземпляра обработчика ошибок (для тестирования)
Public Sub ResetErrorHandler()
    Set mErrorHandler = Nothing
End Sub


'-------------------------------------------
' Component: EventConstants
'-------------------------------------------
' -----------------------------------------------------
' Модуль: EventConstants
' Описание: Константы для типов событий
' -----------------------------------------------------
Option Explicit

' Типы событий
Public Const EVENT_COMMAND_EXECUTED As String = "CommandExecuted"
Public Const EVENT_COMMAND_UNDONE As String = "CommandUndone"
Public Const EVENT_VALIDATION_FAILED As String = "ValidationFailed"
Public Const EVENT_ERROR_OCCURRED As String = "ErrorOccurred"
Public Const EVENT_ERROR_HANDLED As String = "ErrorHandled"
Public Const EVENT_LOG_ENTRY_ADDED As String = "LogEntryAdded"

'-------------------------------------------
' Component: EventBase
'-------------------------------------------
' -----------------------------------------------------
' Класс: EventBase
' Описание: Базовый класс для всех событий
' -----------------------------------------------------
Option Explicit

Private Type TEventBase
    eventType As String     ' Тип события
    Timestamp As Date       ' Время события
    source As String        ' Источник события
End Type

Private this As TEventBase

' Инициализация
Private Sub Class_Initialize()
    this.Timestamp = Now
    this.eventType = ""
    this.source = ""
End Sub

' Инициализация с параметрами
Public Sub Initialize(eventType As String, Optional source As String = "")
    this.eventType = eventType
    this.source = source
    this.Timestamp = Now
End Sub

' Свойства доступа
Public Property Get eventType() As String
    eventType = this.eventType
End Property

Public Property Let eventType(value As String)
    this.eventType = value
End Property

Public Property Get Timestamp() As Date
    Timestamp = this.Timestamp
End Property

Public Property Let Timestamp(value As Date)
    this.Timestamp = value
End Property

Public Property Get source() As String
    source = this.source
End Property

Public Property Let source(value As String)
    this.source = value
End Property

' Клонирование объекта
Public Function Clone() As EventBase
    Dim result As New EventBase
    
    result.eventType = this.eventType
    result.Timestamp = this.Timestamp
    result.source = this.source
    
    Set Clone = result
End Function

'-------------------------------------------
' Component: ValidationEvent
'-------------------------------------------
' -----------------------------------------------------
' Класс: ValidationEvent
' Описание: Событие ошибки валидации
' -----------------------------------------------------
Option Explicit

Private Type TValidationEvent
    baseEvent As EventBase         ' Базовое событие
    command As Object              ' Команда (ICommand)
    ValidationResult As Object     ' Результат валидации (ValidationResult)
End Type

Private this As TValidationEvent

' Инициализация
Private Sub Class_Initialize()
    Set this.baseEvent = New EventBase
    this.baseEvent.Initialize EVENT_VALIDATION_FAILED, TypeName(Me)
End Sub

' Инициализация с параметрами
Public Sub Initialize(command As Object, ValidationResult As Object)
    this.baseEvent.Initialize EVENT_VALIDATION_FAILED, TypeName(Me)
    Set this.command = command
    Set this.ValidationResult = ValidationResult
End Sub

' Свойства доступа
Public Property Get eventType() As String
    eventType = this.baseEvent.eventType
End Property

Public Property Get Timestamp() As Date
    Timestamp = this.baseEvent.Timestamp
End Property

Public Property Get source() As String
    source = this.baseEvent.source
End Property

Public Property Get command() As Object
    Set command = this.command
End Property

Public Property Get ValidationResult() As Object
    Set ValidationResult = this.ValidationResult
End Property

' Клонирование объекта
Public Function Clone() As ValidationEvent
    Dim result As New ValidationEvent
    
    ' Копируем базовое событие
    result.baseEvent.eventType = this.baseEvent.eventType
    result.baseEvent.Timestamp = this.baseEvent.Timestamp
    result.baseEvent.source = this.baseEvent.source
    
    ' Копируем специфичные свойства
    Set result.command = this.command
    Set result.ValidationResult = this.ValidationResult
    
    Set Clone = result
End Function

'-------------------------------------------
' Component: IEventObserver
'-------------------------------------------
' -----------------------------------------------------
' Класс: IEventObserver
' Описание: Интерфейс для наблюдателей событий
' -----------------------------------------------------
Option Explicit

' Обработка события
Public Sub OnEvent(eventObj As Object)
    ' Пустая реализация (должна быть переопределена в наследниках)
End Sub

'-------------------------------------------
' Component: EventManager
'-------------------------------------------
' -----------------------------------------------------
' Класс: EventManager
' Описание: Управление подписками на события
' -----------------------------------------------------
Option Explicit

Private Type TEventManager
    observers As Object      ' Dictionary с ключами = типы событий, значения = коллекции наблюдателей
    Logger As Object         ' Объект логгера
End Type

Private this As TEventManager

' Инициализация
Private Sub Class_Initialize()
    Set this.observers = CreateObject("Scripting.Dictionary")
    Set this.Logger = GetLogger()
End Sub

' Регистрация наблюдателя для типа события
' В классе EventManager
Public Sub RegisterObserver(eventType As String, observer As Object)
    ' Проверяем наличие коллекции для этого типа
    If Not this.observers.Exists(eventType) Then
        Set this.observers(eventType) = New Collection  ' Добавлено Set!
    End If
    
    ' Получаем коллекцию
    Dim observers As Collection
    Set observers = this.observers(eventType)
    
    ' Добавляем наблюдателя
    observers.Add observer
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Наблюдатель зарегистрирован для события " & eventType, "EventManager"
    End If
End Sub

' Отмена регистрации наблюдателя
' Отмена регистрации наблюдателя
Public Sub UnregisterObserver(eventType As String, observer As Object)
    ' Проверяем наличие коллекции для этого типа
    If Not this.observers.Exists(eventType) Then Exit Sub
    
    ' Получаем коллекцию
    Dim observers As Collection
    Set observers = this.observers(eventType)
    
    ' Ищем и удаляем наблюдателя
    Dim i As Long
    For i = observers.count To 1 Step -1
        If observers(i) Is observer Then
            observers.Remove i
            
            If Not this.Logger Is Nothing Then
                this.Logger.LogInfo "Отменена регистрация наблюдателя " & TypeName(observer) & " для события " & eventType, "EventManager"
            End If
            
            Exit For
        End If
    Next i
End Sub

' Уведомление наблюдателей о событии
Public Sub NotifyObservers(eventObj As Object)
    ' Получаем тип события
    Dim eventType As String
    On Error Resume Next
    eventType = eventObj.eventType
    On Error GoTo 0
    
    If Len(eventType) = 0 Then
        If Not this.Logger Is Nothing Then
            this.Logger.LogWarning "Не удалось определить тип события", "EventManager"
        End If
        Exit Sub
    End If
    
    ' Проверяем наличие наблюдателей для этого типа события
    If Not this.observers.Exists(eventType) Then Exit Sub
    
    ' Получаем коллекцию наблюдателей
    Dim observers As Collection
    Set observers = this.observers(eventType)
    
    ' Уведомляем каждого наблюдателя
    Dim observer As IEventObserver
    Dim i As Long
    
    For i = 1 To observers.count
        Set observer = observers(i)
        
        On Error Resume Next
        observer.OnEvent eventObj
        
        If err.Number <> 0 Then
            If Not this.Logger Is Nothing Then
                this.Logger.LogError "Ошибка при уведомлении наблюдателя " & TypeName(observer) & ": " & err.Description, "EventManager"
            End If
        End If
        On Error GoTo 0
    Next i
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogDebug "Уведомлено наблюдателей: " & observers.count & " для события " & eventType, "EventManager"
    End If
End Sub

' Получение количества наблюдателей для типа события
Public Function GetObserverCount(eventType As String) As Long
    ' Проверяем наличие коллекции для этого типа
    If Not this.observers.Exists(eventType) Then
        GetObserverCount = 0
        Exit Function
    End If
    
    ' Получаем коллекцию
    Dim observers As Collection
    Set observers = this.observers(eventType)
    
    GetObserverCount = observers.count
End Function

' Очистка всех наблюдателей
Public Sub ClearObservers()
    Set this.observers = CreateObject("Scripting.Dictionary")
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Все наблюдатели удалены", "EventManager"
    End If
End Sub


'-------------------------------------------
' Component: IComponent
'-------------------------------------------
' -----------------------------------------------------
' Класс: IComponent
' Описание: Интерфейс для компонентов, взаимодействующих с медиатором
' -----------------------------------------------------
Option Explicit

' Получение уникального идентификатора компонента
Public Function GetComponentID() As String
    ' Пустая реализация для интерфейса
End Function

' Установка медиатора
Public Sub SetMediator(mediator As Object)
    ' Пустая реализация для интерфейса
End Sub

' Обработка сообщения
Public Function ProcessMessage(messageType As String, data As Variant) As Boolean
    ' Пустая реализация для интерфейса
End Function

' Обработка события
Public Function HandleEvent(eventObj As Object) As Boolean
    ' Пустая реализация для интерфейса
End Function

'-------------------------------------------
' Component: Mediator
'-------------------------------------------
' -----------------------------------------------------
' Класс: Mediator
' Описание: Центральный компонент для обмена сообщениями и событиями
' -----------------------------------------------------
Option Explicit

Private Type TMediator
    Components As Object     ' Dictionary с компонентами (ключ = ID компонента)
    eventManager As Object   ' Менеджер событий
    Logger As Object         ' Объект логгера
    IsInitialized As Boolean ' Флаг инициализации
End Type

Private this As TMediator

' Инициализация
Private Sub Class_Initialize()
    ' Создаем словарь для компонентов
    Set this.Components = CreateObject("Scripting.Dictionary")
    
    ' Создаем менеджер событий
    Set this.eventManager = New eventManager
    
    ' Получаем логгер
    Set this.Logger = GetLogger()
    
    this.IsInitialized = False
End Sub

' Инициализация медиатора
Public Sub Initialize()
    If this.IsInitialized Then Exit Sub
    
    this.IsInitialized = True
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Медиатор инициализирован", "Mediator"
    End If
End Sub

' Регистрация компонента
Public Sub RegisterComponent(component As IComponent)
    ' Проверка инициализации
    If Not this.IsInitialized Then Initialize
    
    ' Получаем идентификатор
    Dim ComponentID As String
    ComponentID = component.GetComponentID()
    
    ' Проверка уникальности
    If this.Components.Exists(ComponentID) Then
        If Not this.Logger Is Nothing Then
            this.Logger.LogWarning "Компонент с ID '" & ComponentID & "' уже зарегистрирован", "Mediator"
        End If
        Exit Sub
    End If
    
    ' Добавляем компонент
    this.Components.Add ComponentID, component
    
    ' Устанавливаем ссылку на медиатор в компоненте
    component.SetMediator Me
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Компонент '" & ComponentID & "' зарегистрирован", "Mediator"
    End If
End Sub

' Удаление компонента
Public Sub UnregisterComponent(ComponentID As String)
    ' Проверка инициализации
    If Not this.IsInitialized Then Initialize
    
    ' Проверяем существование компонента
    If Not this.Components.Exists(ComponentID) Then
        If Not this.Logger Is Nothing Then
            this.Logger.LogWarning "Компонент с ID '" & ComponentID & "' не найден", "Mediator"
        End If
        Exit Sub
    End If
    
    ' Удаляем компонент
    this.Components.Remove ComponentID
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Компонент '" & ComponentID & "' удален", "Mediator"
    End If
End Sub

' Отправка сообщения конкретному компоненту
Public Function SendMessage(targetComponentID As String, messageType As String, data As Variant) As Boolean
    ' Проверка инициализации
    If Not this.IsInitialized Then Initialize
    
    ' Проверяем существование компонента
    If Not this.Components.Exists(targetComponentID) Then
        If Not this.Logger Is Nothing Then
            this.Logger.LogWarning "Компонент с ID '" & targetComponentID & "' не найден", "Mediator"
        End If
        SendMessage = False
        Exit Function
    End If
    
    ' Получаем компонент
    Dim component As IComponent
    Set component = this.Components(targetComponentID)
    
    ' Отправляем сообщение
    On Error Resume Next
    SendMessage = component.ProcessMessage(messageType, data)
    
    If err.Number <> 0 Then
        If Not this.Logger Is Nothing Then
            this.Logger.LogError "Ошибка при отправке сообщения '" & messageType & "' компоненту '" & _
                                targetComponentID & "': " & err.Description, "Mediator"
        End If
        SendMessage = False
    End If
    On Error GoTo 0
    
    If Not this.Logger Is Nothing Then
        If SendMessage Then
            this.Logger.LogDebug "Сообщение '" & messageType & "' обработано компонентом '" & targetComponentID & "'", "Mediator"
        Else
            this.Logger.LogWarning "Сообщение '" & messageType & "' не обработано компонентом '" & targetComponentID & "'", "Mediator"
        End If
    End If
End Function

' Отправка сообщения всем компонентам
Public Function BroadcastMessage(messageType As String, data As Variant) As Long
    ' Проверка инициализации
    If Not this.IsInitialized Then Initialize
    
    ' Счетчик компонентов, обработавших сообщение
    Dim componentsProcessed As Long
    componentsProcessed = 0
    
    ' Логирование
    If Not this.Logger Is Nothing Then
        this.Logger.LogDebug "Отправка широковещательного сообщения типа '" & messageType & "'", "Mediator"
    End If
    
    ' Проверка инициализации словаря компонентов
    If this.Components Is Nothing Then
        If Not this.Logger Is Nothing Then
            this.Logger.LogError "Словарь компонентов не инициализирован", "Mediator"
        End If
        BroadcastMessage = 0
        Exit Function
    End If
    
    ' Отправляем сообщение всем компонентам
    Dim key As Variant
    Dim component As IComponent
    
    On Error Resume Next
    For Each key In this.Components.Keys
        Set component = this.Components(key)
        
        If Not component Is Nothing Then
            If component.ProcessMessage(messageType, data) Then
                componentsProcessed = componentsProcessed + 1
            End If
        End If
    Next key
    On Error GoTo 0
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogDebug "Сообщение обработано " & componentsProcessed & " компонентами", "Mediator"
    End If
    
    BroadcastMessage = componentsProcessed
End Function

' Публикация события
Public Sub PublishEvent(eventObj As Object)
    ' Проверка инициализации
    If Not this.IsInitialized Then Initialize
    
    ' Проверка объекта события
    If eventObj Is Nothing Then
        If Not this.Logger Is Nothing Then
            this.Logger.LogWarning "Попытка опубликовать пустое событие", "Mediator"
        End If
        Exit Sub
    End If
    
    ' Получаем тип события
    Dim eventType As String
    On Error Resume Next
    eventType = eventObj.eventType
    On Error GoTo 0
    
    If Len(eventType) = 0 Then
        If Not this.Logger Is Nothing Then
            this.Logger.LogWarning "Не удалось определить тип события", "Mediator"
        End If
        Exit Sub
    End If
    
    ' Логирование
    If Not this.Logger Is Nothing Then
        this.Logger.LogDebug "Публикация события типа '" & eventType & "'", "Mediator"
    End If
    
    ' Уведомляем наблюдателей через менеджер событий
    this.eventManager.NotifyObservers eventObj
    
    ' Отправляем событие всем компонентам
    Dim key As Variant
    Dim component As IComponent
    Dim componentsProcessed As Long
    componentsProcessed = 0
    
    On Error Resume Next
    For Each key In this.Components.Keys
        Set component = this.Components(key)
        
        If Not component Is Nothing Then
            If component.HandleEvent(eventObj) Then
                componentsProcessed = componentsProcessed + 1
            End If
        End If
    Next key
    On Error GoTo 0
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogDebug "Событие обработано " & componentsProcessed & " компонентами", "Mediator"
    End If
End Sub

' Регистрация наблюдателя для события
' В классе Mediator
Public Sub RegisterObserver(eventType As String, observer As Object)
    this.eventManager.RegisterObserver eventType, observer
End Sub

' Отмена регистрации наблюдателя
Public Sub UnregisterObserver(eventType As String, observer As Object)
    this.eventManager.UnregisterObserver eventType, observer
End Sub

' Методы уведомления о различных событиях

' Уведомление о выполнении команды
Public Sub NotifyCommandExecuted(command As Object, success As Boolean)
    ' Создаем событие
    Dim cEvent As New CommandEvent
    cEvent.InitializeExecuted command, success, IIf(Not success, "Команда не выполнена", "")
    
    ' Публикуем событие
    PublishEvent cEvent
    
    ' Логируем событие
    If Not this.Logger Is Nothing Then
        Dim resultStr As String
        resultStr = IIf(success, "успешно", "неуспешно")
        
        this.Logger.LogInfo "Команда " & command.GetCommandName() & " выполнена " & resultStr, "Mediator"
    End If
End Sub

' Уведомление об отмене команды
Public Sub NotifyCommandUndone(command As Object, success As Boolean)
    ' Создаем событие
    Dim cEvent As New CommandEvent
    cEvent.InitializeUndone command, success, IIf(Not success, "Команда не отменена", "")
    
    ' Публикуем событие
    PublishEvent cEvent
    
    ' Логируем событие
    If Not this.Logger Is Nothing Then
        Dim resultStr As String
        resultStr = IIf(success, "успешно", "неуспешно")
        
        this.Logger.LogInfo "Команда " & command.GetCommandName() & " отменена " & resultStr, "Mediator"
    End If
End Sub

' Уведомление о возникновении ошибки
Public Sub NotifyErrorOccurred(errorInfo As errorInfo)
    ' Создаем событие
    Dim cEvent As New EventBase
    cEvent.Initialize EVENT_ERROR_OCCURRED
    
    ' Устанавливаем дополнительные свойства
    ' В идеале нужно создать специальный класс для события ошибки
    
    ' Публикуем событие
    PublishEvent cEvent
    
    ' Логируем событие
    If Not this.Logger Is Nothing Then
        this.Logger.LogError "Произошла ошибка: " & errorInfo.Description, "Mediator"
    End If
End Sub

' Уведомление об обработке ошибки
Public Sub NotifyErrorHandled(errorInfo As errorInfo)
    ' Создаем событие
    Dim cEvent  As New EventBase
    cEvent.Initialize EVENT_ERROR_HANDLED
    
    ' Публикуем событие
    PublishEvent cEvent
    
    ' Логируем событие
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Ошибка обработана: " & errorInfo.Description, "Mediator"
    End If
End Sub

' Уведомление о создании записи в логе
Public Sub NotifyLogEntryAdded(entry As LogEntry)
    ' Создаем событие
    Dim cEvent As New EventBase
    cEvent.Initialize EVENT_LOG_ENTRY_ADDED
    
    ' Публикуем событие
    PublishEvent cEvent
End Sub

' Свойства доступа
Public Property Get Components() As Object
    Set Components = this.Components
End Property

Public Property Get eventManager() As Object
    Set eventManager = this.eventManager
End Property

Public Property Get IsInitialized() As Boolean
    IsInitialized = this.IsInitialized
End Property


'-------------------------------------------
' Component: MediatorModule
'-------------------------------------------
' -----------------------------------------------------
' Модуль: MediatorModule
' Описание: Глобальный доступ к медиатору
' -----------------------------------------------------
Option Explicit

' Экземпляр медиатора
Private mMediator As mediator

' Получение экземпляра медиатора
' Исправьте метод GetMediator в модуле MediatorModule.bas
Public Function GetMediator() As mediator
    ' Добавьте статическую переменную для отслеживания инициализации
    Static isInitializing As Boolean
    
    ' Проверяем флаг, чтобы избежать рекурсии
    If isInitializing Then
        ' Возвращаем null, если в процессе инициализации
        Set GetMediator = mMediator
        Exit Function
    End If
    
    isInitializing = True
    
    ' Создаем экземпляр, если еще не создан
    If mMediator Is Nothing Then
        Set mMediator = New mediator
        mMediator.Initialize
    End If
    
    isInitializing = False
    Set GetMediator = mMediator
End Function

' Сброс экземпляра медиатора (для тестирования)
Public Sub ResetMediator()
    Set mMediator = Nothing
End Sub

'-------------------------------------------
' Component: ExcelCommandFactory
'-------------------------------------------
' -----------------------------------------------------
' Класс: ExcelCommandFactory
' Описание: Фабрика для создания команд Excel
' -----------------------------------------------------
Option Explicit

' Создание команды установки значения ячейки
Public Function CreateSetValueCommand(sheetName As String, cellAddress As String, value As Variant) As ICommand
    Dim command As New SetCellValueCommand
    command.Initialize sheetName, cellAddress, value
    Set CreateSetValueCommand = command
End Function

' Создание команды установки цвета фона ячейки
Public Function CreateSetColorCommand(sheetName As String, cellAddress As String, color As Long) As ICommand
    Dim command As New SetCellColorCommand
    command.Initialize sheetName, cellAddress, color
    Set CreateSetColorCommand = command
End Function

' Создание команды по типу и параметрам
Public Function CreateCommand(commandType As String, params As Object) As ICommand
    ' Проверяем параметры
    If params Is Nothing Then
        err.Raise vbObjectError + 10100, "ExcelCommandFactory", "Параметры не заданы"
        Set CreateCommand = Nothing
        Exit Function
    End If
    
    ' Создаем команду в зависимости от типа
    Select Case commandType
        Case "SetValue"
            ' Проверяем наличие необходимых параметров
            If Not (params.Exists("Sheet") And params.Exists("Cell") And params.Exists("Value")) Then
                err.Raise vbObjectError + 10101, "ExcelCommandFactory", "Недостаточно параметров для создания команды SetValue"
                Set CreateCommand = Nothing
                Exit Function
            End If
            
            ' Создаем команду
            Set CreateCommand = CreateSetValueCommand(params("Sheet"), params("Cell"), params("Value"))
            
        Case "SetColor"
            ' Проверяем наличие необходимых параметров
            If Not (params.Exists("Sheet") And params.Exists("Cell") And params.Exists("Color")) Then
                err.Raise vbObjectError + 10102, "ExcelCommandFactory", "Недостаточно параметров для создания команды SetColor"
                Set CreateCommand = Nothing
                Exit Function
            End If
            
            ' Создаем команду
            Set CreateCommand = CreateSetColorCommand(params("Sheet"), params("Cell"), params("Color"))
            
        Case Else
            err.Raise vbObjectError + 10103, "ExcelCommandFactory", "Неизвестный тип команды: " & commandType
            Set CreateCommand = Nothing
    End Select
End Function

'-------------------------------------------
' Component: CommandFacade
'-------------------------------------------
' -----------------------------------------------------
' Класс: CommandFacade
' Описание: Фасад для упрощения работы с командной системой
' -----------------------------------------------------
Option Explicit

Private Type TCommandFacade
    Factory As ExcelCommandFactory   ' Фабрика для создания команд
    Invoker As CommandInvoker        ' Инвокер для выполнения команд
    mediator As mediator             ' Медиатор для коммуникации
    Logger As Object                 ' Объект логгера
    IsInitialized As Boolean         ' Флаг инициализации
End Type

Private this As TCommandFacade

' Инициализация
Private Sub Class_Initialize()
    ' Создаем компоненты
    Set this.Factory = New ExcelCommandFactory
    Set this.Invoker = New CommandInvoker
    
    ' Получаем глобальные сервисы
    Set this.mediator = GetMediator()
    Set this.Logger = GetLogger()
    
    this.IsInitialized = False
End Sub

' Инициализация фасада
Public Sub Initialize()
    If this.IsInitialized Then Exit Sub
    
    this.IsInitialized = True
    
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Фасад командной системы инициализирован", "CommandFacade"
    End If
End Sub

' Установка значения ячейки
Public Function SetCellValue(sheetName As String, cellAddress As String, value As Variant) As Boolean
    ' Проверка инициализации
    If Not this.IsInitialized Then Initialize
    
    ' Логирование
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Установка значения '" & value & "' в ячейку " & sheetName & "!" & cellAddress, "CommandFacade"
    End If
    
    ' Создаем команду через фабрику
    Dim command As ICommand
    Set command = this.Factory.CreateSetValueCommand(sheetName, cellAddress, value)
    
    ' Выполняем команду через инвокер
    SetCellValue = this.Invoker.Execute(command)
End Function

' Установка цвета фона ячейки
Public Function SetCellColor(sheetName As String, cellAddress As String, color As Long) As Boolean
    ' Проверка инициализации
    If Not this.IsInitialized Then Initialize
    
    ' Логирование
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Установка цвета #" & Hex(color) & " в ячейку " & sheetName & "!" & cellAddress, "CommandFacade"
    End If
    
    ' Создаем команду через фабрику
    Dim command As ICommand
    Set command = this.Factory.CreateSetColorCommand(sheetName, cellAddress, color)
    
    ' Выполняем команду через инвокер
    SetCellColor = this.Invoker.Execute(command)
End Function

' Выполнение произвольной команды
Public Function ExecuteCommand(command As ICommand) As Boolean
    ' Проверка инициализации
    If Not this.IsInitialized Then Initialize
    
    ' Проверка входных данных
    If command Is Nothing Then
        If Not this.Logger Is Nothing Then
            this.Logger.LogWarning "Попытка выполнить пустую команду", "CommandFacade"
        End If
        ExecuteCommand = False
        Exit Function
    End If
    
    ' Логирование
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Выполнение команды: " & command.GetCommandName(), "CommandFacade"
    End If
    
    ' Выполняем команду через инвокер
    ExecuteCommand = this.Invoker.Execute(command)
End Function

' Отмена последней команды
Public Function UndoLastCommand() As Boolean
    ' Проверка инициализации
    If Not this.IsInitialized Then Initialize
    
    ' Логирование
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "Отмена последней команды", "CommandFacade"
    End If
    
    ' Отмена через инвокер
    UndoLastCommand = this.Invoker.UndoLastCommand()
End Function

' Получение истории команд
Public Function GetCommandHistory() As Collection
    Set GetCommandHistory = this.Invoker.GetCommandHistory()
End Function

' Получение количества команд в истории
Public Function GetHistoryCount() As Long
    GetHistoryCount = this.Invoker.GetHistoryCount()
End Function

' Очистка истории команд
Public Sub ClearHistory()
    this.Invoker.ClearHistory
    
    ' Логирование
    If Not this.Logger Is Nothing Then
        this.Logger.LogInfo "История команд очищена", "CommandFacade"
    End If
End Sub

' Свойства доступа
Public Property Get Factory() As ExcelCommandFactory
    Set Factory = this.Factory
End Property

Public Property Get Invoker() As CommandInvoker
    Set Invoker = this.Invoker
End Property

Public Property Get mediator() As mediator
    Set mediator = this.mediator
End Property

Public Property Get IsInitialized() As Boolean
    IsInitialized = this.IsInitialized
End Property

Public Property Get LastError() As String
    LastError = this.Invoker.LastError
End Property

'-------------------------------------------
' Component: CommandManagerComponent
'-------------------------------------------
' -----------------------------------------------------
' Класс: CommandManagerComponent
' Описание: Компонент для управления командами через медиатор
' -----------------------------------------------------
Option Explicit

Implements IComponent

Private Type TCommandManagerComponent
    ComponentID As String        ' Идентификатор компонента
    mediator As Object           ' Ссылка на медиатор
    facade As CommandFacade      ' Фасад командной системы
    Logger As Object             ' Объект логгера
End Type

Private this As TCommandManagerComponent

' Инициализация
Private Sub Class_Initialize()
    this.ComponentID = "CommandManager"
    Set this.facade = GetCommandFacade()
    Set this.Logger = GetLogger()
End Sub

' Реализация IComponent

Private Function IComponent_GetComponentID() As String
    IComponent_GetComponentID = this.ComponentID
End Function

Private Sub IComponent_SetMediator(mediator As Object)
    Set this.mediator = mediator
End Sub

Private Function IComponent_ProcessMessage(messageType As String, data As Variant) As Boolean
    ' Обрабатываем только сообщения определенных типов
    Select Case messageType
        Case "ExecuteCommand"
            ' Выполнение команды
            IComponent_ProcessMessage = ProcessExecuteCommand(data)
            
        Case "UndoCommand"
            ' Отмена последней команды
            IComponent_ProcessMessage = this.facade.UndoLastCommand()
            
        Case "ClearHistory"
            ' Очистка истории команд
            this.facade.ClearHistory
            IComponent_ProcessMessage = True
            
        Case Else
            ' Неизвестный тип сообщения
            IComponent_ProcessMessage = False
    End Select
End Function

Private Function IComponent_HandleEvent(eventObj As Object) As Boolean
    ' Проверяем тип события
    On Error Resume Next
    Dim eventType As String
    eventType = eventObj.eventType
    On Error GoTo 0
    
    ' Обрабатываем события выполнения команд
    Select Case eventType
        Case EVENT_COMMAND_EXECUTED
            ' Логируем информацию о выполненной команде
            On Error Resume Next
            If eventObj.success Then
                this.Logger.LogInfo "Команда выполнена успешно: " & eventObj.command.GetCommandName(), "CommandManagerComponent"
            Else
                this.Logger.LogWarning "Команда не выполнена: " & eventObj.command.GetCommandName(), "CommandManagerComponent"
            End If
            On Error GoTo 0
            IComponent_HandleEvent = True
            
        Case EVENT_COMMAND_UNDONE
            ' Логируем информацию об отмененной команде
            On Error Resume Next
            If eventObj.success Then
                this.Logger.LogInfo "Команда отменена успешно: " & eventObj.command.GetCommandName(), "CommandManagerComponent"
            Else
                this.Logger.LogWarning "Команда не отменена: " & eventObj.command.GetCommandName(), "CommandManagerComponent"
            End If
            On Error GoTo 0
            IComponent_HandleEvent = True
            
        Case Else
            ' Неизвестный тип события
            IComponent_HandleEvent = False
    End Select
End Function

' Приватные вспомогательные методы
Private Function ProcessExecuteCommand(data As Variant) As Boolean
    ' Предыдущий код без изменений
    
    ' Проверяем тип команды
    If data.Exists("CommandType") Then
        Dim commandType As String
        commandType = data("CommandType")
        
        ' Специализированное выполнение команд
        Select Case commandType
            Case "SetValue"
                ' Проверяем необходимые параметры
                If Not (data.Exists("Sheet") And data.Exists("Cell") And data.Exists("Value")) Then
                    this.Logger.LogWarning "Недостаточно параметров для создания команды SetValue", "CommandManagerComponent"
                    ProcessExecuteCommand = False
                    Exit Function
                End If
                
                ' Сохраняем значения в переменные
                Dim sheet As String
                Dim cell As String
                Dim value As Variant
                sheet = data("Sheet")
                cell = data("Cell")
                value = data("Value")
                
                ' Выполняем команду через фасад
                ProcessExecuteCommand = this.facade.SetCellValue(sheet, cell, value)
                
            Case "SetColor"
                ' Проверяем необходимые параметры
                If Not (data.Exists("Sheet") And data.Exists("Cell") And data.Exists("Color")) Then
                    this.Logger.LogWarning "Недостаточно параметров для создания команды SetColor", "CommandManagerComponent"
                    ProcessExecuteCommand = False
                    Exit Function
                End If
                
                ' Сохраняем значения в переменные
                Dim colorSheet As String
                Dim colorCell As String
                Dim colorValue As Long
                colorSheet = data("Sheet")
                colorCell = data("Cell")
                colorValue = data("Color")
                
                ' Выполняем команду через фасад
                ProcessExecuteCommand = this.facade.SetCellColor(colorSheet, colorCell, colorValue)
                
            Case Else
                ' Остальной код без изменений
        End Select
    Else
        ' Остальной код без изменений
    End If
End Function

'-------------------------------------------
' Component: CommandFacadeModule
'-------------------------------------------
' -----------------------------------------------------
' Модуль: CommandFacadeModule
' Описание: Глобальный доступ к фасаду командной системы
' -----------------------------------------------------
Option Explicit

' Экземпляр фасада
Private mCommandFacade As CommandFacade

' Получение экземпляра фасада
Public Function GetCommandFacade() As CommandFacade
    ' Создаем экземпляр, если еще не создан
    If mCommandFacade Is Nothing Then
        Set mCommandFacade = New CommandFacade
        mCommandFacade.Initialize
    End If
    
    Set GetCommandFacade = mCommandFacade
End Function

' Сброс экземпляра фасада (для тестирования)
Public Sub ResetCommandFacade()
    Set mCommandFacade = Nothing
End Sub

'-------------------------------------------
' Component: MediatorObserverTest
'-------------------------------------------
Sub TestSimpleCommands()
    ' Получаем фасад
    Dim facade As CommandFacade
    Set facade = GetCommandFacade()
    
    ' Устанавливаем значение ячейки
    If facade.SetCellValue("Sheet1", "A1", "Hello, World!") Then
        Debug.Print "Значение установлено успешно"
    Else
        Debug.Print "Ошибка: " & facade.LastError
    End If
    
    ' Устанавливаем цвет фона
    If facade.SetCellColor("Sheet1", "A1", RGB(255, 0, 0)) Then
        Debug.Print "Цвет установлен успешно"
    Else
        Debug.Print "Ошибка: " & facade.LastError
    End If
    
    ' Отмена последней команды (возврат к предыдущему цвету)
    If facade.UndoLastCommand() Then
        Debug.Print "Команда отменена успешно"
    Else
        Debug.Print "Ошибка отмены: " & facade.LastError
    End If
    
    ' Вывод количества команд в истории
    Debug.Print "Команд в истории: " & facade.GetHistoryCount()
End Sub
' Наблюдатель для отладки
Private Sub CreateDebugObserver()
    Dim mediator As mediator  ' С большой буквы!
    Set mediator = GetMediator()
    
    ' Создаем наблюдателя
    Dim dbgObserver As Object  ' Используем Object вместо конкретного типа
    Set dbgObserver = New debugObserver
    
    ' Регистрируем для всех типов событий
    mediator.RegisterObserver EVENT_COMMAND_EXECUTED, dbgObserver
    mediator.RegisterObserver EVENT_COMMAND_UNDONE, dbgObserver
    mediator.RegisterObserver EVENT_ERROR_OCCURRED, dbgObserver
End Sub

' Тестирование обмена сообщениями
Sub TestMediator()
    ' Получаем медиатор
    Dim mediator As Object
    Set mediator = GetMediator()
    
    ' Создаем наблюдателя
    Dim debugObserver As New debugObserver
    
    ' ВАЖНО: Явное приведение к интерфейсному типу
    Dim observerInterface As IEventObserver
    Set observerInterface = debugObserver
    
    ' Теперь регистрируем наблюдателя через интерфейс
    mediator.RegisterObserver EVENT_COMMAND_EXECUTED, observerInterface
    mediator.RegisterObserver EVENT_COMMAND_UNDONE, observerInterface
    
    ' Регистрируем компоненты
    ' Используем Object для компонентов
    Dim loggerComp As Object
    Set loggerComp = New loggerComponent
    mediator.RegisterComponent loggerComp
    
    Dim commandManager As Object
    Set commandManager = New CommandManagerComponent
    mediator.RegisterComponent commandManager
    
    ' Отправляем сообщение для логирования
    Dim data As Object
    Set data = CreateObject("Scripting.Dictionary")
    data.Add "Message", "Тестовое сообщение"
    data.Add "Level", logLevel.LogInfo
    data.Add "Source", "TestMediator"
    
    mediator.SendMessage "Logger", "LogMessage", data
    
    ' Создаем команду через медиатор
    Set data = CreateObject("Scripting.Dictionary")
    data.Add "CommandType", "SetValue"
    data.Add "Sheet", "Sheet1"
    data.Add "Cell", "A1"
    data.Add "Value", "Тест через медиатор"
    
    mediator.SendMessage "CommandManager", "ExecuteCommand", data
    
    ' Отменяем команду
    mediator.SendMessage "CommandManager", "UndoCommand", Nothing
    
    ' Отправляем широковещательное сообщение
    Set data = CreateObject("Scripting.Dictionary")
    data.Add "Message", "Широковещательное сообщение"
    
    Dim componentsProcessed As Long
    componentsProcessed = mediator.BroadcastMessage("TestMessage", data)
    
    Debug.Print "Сообщение обработано " & componentsProcessed & " компонентами"
End Sub

Sub TestWithDebugObserver()
    ' Создаем и тестируем наблюдателя напрямую
    Dim observer As New debugObserver ' Убедитесь, что класс создан в проекте
    
    ' Проверяем, создался ли объект
    If observer Is Nothing Then
        Debug.Print "ОШИБКА: Не удалось создать наблюдателя"
        Exit Sub
    Else
        Debug.Print "Наблюдатель создан успешно"
    End If
    
    ' Далее тестируем метод для убеждения, что он работает
    Dim testEvent As New EventBase
    testEvent.Initialize "TestEvent", "TestSource"
    
    ' Вызываем метод наблюдателя напрямую
    observer.OnEvent testEvent
    
    Debug.Print "Тест завершен"
End Sub

Sub TestErrorHandling()
    ' Получаем обработчик ошибок
    Dim errorHandler As errorHandler
    Set errorHandler = GetErrorHandler()
    
    ' Регистрируем стратегию для конкретного кода ошибки
    Dim dialogStrategy As New DialogErrorStrategy
    errorHandler.RegisterStrategy 91, dialogStrategy ' Ошибка "Object variable not set"
    
    ' Эмулируем ошибку
    On Error Resume Next
    Dim obj As Object
    obj.value = 123  ' Вызовет ошибку 91
    
    ' Обрабатываем ошибку
    If err.Number <> 0 Then
        errorHandler.HandleError err, "TestErrorHandling", Nothing
    End If
    On Error GoTo 0
    
    ' Количество ошибок в истории
    Debug.Print "Ошибок в истории: " & errorHandler.ErrorHistory.count
End Sub

Sub TestMediato2r()
    Dim mediator As mediator
    Set mediator = GetMediator()
    
    Debug.Print "Медиатор получен успешно"
    Debug.Print "Медиатор инициализирован: " & mediator.IsInitialized
End Sub

Sub SimpleTest()
    ' Создаем фасад
    Dim facade As CommandFacade
    Set facade = GetCommandFacade()
    
    ' Простая операция - установка значения ячейки
    Dim result As Boolean
    result = facade.SetCellValue("Лист1", "A1", "Тестовое значение")
    
    ' Выводим результат
    If result Then
        MsgBox "Команда выполнена успешно", vbInformation
    Else
        MsgBox "Ошибка: " & facade.LastError, vbExclamation
    End If
End Sub

Sub CheckEventConstants()
    ' Проверяем определение констант
    Debug.Print "EVENT_COMMAND_EXECUTED = " & EVENT_COMMAND_EXECUTED
    Debug.Print "EVENT_COMMAND_UNDONE = " & EVENT_COMMAND_UNDONE
    Debug.Print "EVENT_ERROR_OCCURRED = " & EVENT_ERROR_OCCURRED
End Sub

Sub InspectMediator()
    ' Получаем и проверяем медиатор
    Dim mediator As Object
    Set mediator = GetMediator()
    
    ' Выводим информацию о медиаторе
    Debug.Print "Mediator Object: " & TypeName(mediator)
    Debug.Print "Is Initialized: " & mediator.IsInitialized
    
    ' Получаем EventManager
    Dim eventManager As Object
    Set eventManager = mediator.eventManager
    
    Debug.Print "EventManager Object: " & TypeName(eventManager)
End Sub


Sub SimpleMediatorTest()
    ' Получаем медиатор
    Dim mediator As Object
    Set mediator = GetMediator()
    
    ' Регистрируем только компоненты
    Dim loggerComp As New loggerComponent
    mediator.RegisterComponent loggerComp
    
    ' Отправляем простое сообщение
    Dim data As Object
    Set data = CreateObject("Scripting.Dictionary")
    data.Add "Message", "Тестовое сообщение"
    data.Add "Level", logLevel.LogInfo
    
    mediator.SendMessage "Logger", "LogMessage", data
    
    Debug.Print "Сообщение отправлено успешно"
End Sub

Sub TestWithEventManager()
    ' Получаем медиатор
    Dim mediator As Object
    Set mediator = GetMediator()
    
    ' Создаем наблюдателя
    Dim observer As New debugObserver
    
    ' Приводим объект к типу интерфейса
    Dim eventObserver As IEventObserver
    Set eventObserver = observer
    
    ' Регистрируем наблюдателя через интерфейс
    mediator.RegisterObserver EVENT_COMMAND_EXECUTED, eventObserver
    
    Debug.Print "Наблюдатель зарегистрирован успешно"
    
    ' Создаем тестовое событие
    Dim testEvent As New CommandEvent
    testEvent.InitializeExecuted Nothing, True  ' Пустая команда для теста
    
    ' Публикуем событие
    mediator.PublishEvent testEvent
    
    Debug.Print "Событие опубликовано"
End Sub

Sub TestMediatorEvent()
    ' Получаем медиатор
    Dim mediator As Object
    Set mediator = GetMediator()
    
    ' Создаем простое событие и публикуем его
    Dim baseEvent As New EventBase
    baseEvent.Initialize "TestEvent"
    
    ' Публикуем событие (это не требует наблюдателей)
    mediator.PublishEvent baseEvent
    
    Debug.Print "Событие опубликовано успешно"
End Sub

'-------------------------------------------
' Component: LoggerComponent
'-------------------------------------------
' -----------------------------------------------------
' Класс: LoggerComponent
' Описание: Компонент для логирования через медиатор
' -----------------------------------------------------
Option Explicit

Implements IComponent

Private Type TLoggerComponent
    ComponentID As String        ' Идентификатор компонента
    mediator As Object           ' Ссылка на медиатор
    Logger As Object             ' Объект логгера
End Type

Private this As TLoggerComponent

' Инициализация
Private Sub Class_Initialize()
    this.ComponentID = "Logger"
    Set this.Logger = GetLogger()
End Sub

' Реализация IComponent

Private Function IComponent_GetComponentID() As String
    IComponent_GetComponentID = this.ComponentID
End Function

Private Sub IComponent_SetMediator(mediator As Object)
    Set this.mediator = mediator
End Sub

Private Function IComponent_ProcessMessage(messageType As String, data As Variant) As Boolean
    ' Обрабатываем только сообщения определенных типов
    Select Case messageType
        Case "LogMessage"
            ' Проверяем данные
            If Not IsObject(data) Then
                this.Logger.LogWarning "Получены неверные данные для логирования", "LoggerComponent"
                IComponent_ProcessMessage = False
                Exit Function
            End If
            
            ' Проверяем наличие сообщения
            On Error Resume Next
            If data.Exists("Message") Then
                ' Логируем сообщение
                Dim message As String
                message = data("Message")
                
                ' Определяем уровень логирования
                Dim level As logLevel
                If data.Exists("Level") Then
                    level = data("Level")
                Else
                    level = logLevel.LogInfo
                End If
                
                ' Определяем источник
                Dim source As String
                If data.Exists("Source") Then
                    source = data("Source")
                Else
                    source = "Unknown"
                End If
                
                ' Логируем
                this.Logger.Log level, message, source
                IComponent_ProcessMessage = True
            Else
                this.Logger.LogWarning "Сообщение для логирования не содержит поле Message", "LoggerComponent"
                IComponent_ProcessMessage = False
            End If
            On Error GoTo 0
            
        Case "ClearLog"
            ' Очищаем историю логирования
            this.Logger.ClearHistory
            IComponent_ProcessMessage = True
            
        Case Else
            ' Неизвестный тип сообщения
            IComponent_ProcessMessage = False
    End Select
End Function

Private Function IComponent_HandleEvent(eventObj As Object) As Boolean
    ' По умолчанию не обрабатываем события
    IComponent_HandleEvent = False
End Function

' Публичные методы
Public Sub LogMessage(message As String, Optional level As logLevel = logLevel.LogInfo, Optional source As String = "")
    ' Логируем напрямую
    this.Logger.Log level, message, source
    
    ' Уведомляем через медиатор, если он доступен
    If Not this.mediator Is Nothing Then
        Dim data As Object
        Set data = CreateObject("Scripting.Dictionary")
        data.Add "Message", message
        data.Add "Level", level
        data.Add "Source", source
        
        this.mediator.BroadcastMessage "LogNotification", data
    End If
End Sub

'-------------------------------------------
' Component: DebugObserver
'-------------------------------------------
' -----------------------------------------------------
' Класс: DebugObserver
' Описание: Наблюдатель для отладки событий
' -----------------------------------------------------
Option Explicit

Implements IEventObserver



' Публичный метод для прямого вызова (добавьте этот метод)
Public Sub OnEvent(eventObj As Object)
    ' Делегируем вызов методу интерфейса
    IEventObserver_OnEvent eventObj
End Sub

' Реализация интерфейса (оставьте как есть)

' Обработка события
' В классе DebugObserver
Private Sub IEventObserver_OnEvent(eventObj As Object)
    ' В начале метода добавьте отладочный вывод
    Debug.Print "IEventObserver_OnEvent вызван!"
    On Error Resume Next
    Dim eventType As String
    eventType = eventObj.eventType
    On Error GoTo 0
    
    ' Логирование в окно Immediate
    Debug.Print "---------- DEBUG EVENT ----------"
    Debug.Print "Event Type: " & eventType
    Debug.Print "Timestamp: " & Format(Now, "yyyy-mm-dd hh:nn:ss")
    
    ' Дополнительная информация по типу события
    Select Case eventType
        Case EVENT_COMMAND_EXECUTED
            On Error Resume Next
            Debug.Print "Command: " & eventObj.command.GetCommandName()
            Debug.Print "Success: " & eventObj.success
            If Not eventObj.success And Len(eventObj.ErrorMessage) > 0 Then
                Debug.Print "Error: " & eventObj.ErrorMessage
            End If
            On Error GoTo 0
            
        Case EVENT_COMMAND_UNDONE
            On Error Resume Next
            Debug.Print "Command: " & eventObj.command.GetCommandName()
            Debug.Print "Success: " & eventObj.success
            If Not eventObj.success And Len(eventObj.ErrorMessage) > 0 Then
                Debug.Print "Error: " & eventObj.ErrorMessage
            End If
            On Error GoTo 0
            
        Case EVENT_ERROR_OCCURRED
            On Error Resume Next
            Debug.Print "Error Number: " & eventObj.errorInfo.Number
            Debug.Print "Error Description: " & eventObj.errorInfo.Description
            Debug.Print "Error Source: " & eventObj.errorInfo.source
            Debug.Print "Error Severity: " & eventObj.errorInfo.Severity
            On Error GoTo 0
            
        Case EVENT_LOG_ENTRY_ADDED
            On Error Resume Next
            Debug.Print "Log Message: " & eventObj.message
            Debug.Print "Log Level: " & LogLevelToString(eventObj.level)
            Debug.Print "Log Source: " & eventObj.source
            On Error GoTo 0
            
        Case Else
            Debug.Print "Unknown Event Type: " & eventType
    End Select
    
    Debug.Print "-----------------------------"
End Sub

